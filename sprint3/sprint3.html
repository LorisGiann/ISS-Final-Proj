<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
    <!--
<link rel="stylesheet" type="text/css" href="../css/issStyle1.css">
<script type="text/javascript" src="../css/issStyle.js"></script>
-->
<link rel="stylesheet" type="text/css" href="../docs_common/defaultTemplateStyle.css">
<style>
code>pre { 
    font-family: monospace;
}
dd{
    margin-bottom: 7px;
}
.todo{
    color: orange
}
.centerimg{
    display: block;
    padding-top: 8px;
    padding-bottom: 8px;
    margin-left: auto;
    margin-right: auto;
    width: 90%;
    max-width: 800px;
}
p { margin: 4px 0px; }
dd{ margin-bottom: 8px;}
.newDictWord{ color : purple; }
h6{
    font-size: 1em;
    margin: 18px 0px 9px 0px;
}
</style>
<head><title>WasteService SPRINT3</title></head>
    
<body>
<div id="top">
<h1>ISS FINAL PROJECT </h1>
</div>  

<div class="body"> 
<h2>Introduction</h2>
<div class="remark">
    <p>Progetto finale di ISS, che consiste in un impianto di smistamento dei rifiuti nel quale un robot deve trasportare il materiale dal camion al relativo container</p>
</div>

<h2>Requirements</h2>
<div class="remark">
    <a href="../docs_prof/html/TemaFinale22.html">Link alla pagina dei requisiti del committente</a> <br>
    <a href="../sprint0/sprint0.html#Requirements">Requisiti sprint0</a>
</div>

<h2>Requirement analysis</h2>
<div class="remark">
    La <b>WasteServiceStatusGUI:</b> deve permette al <b>Service-manager</b> di monitorare:
    <ul>
        <lI>La <b>Position</b> del <b>Transport trolley</b> (non è necessaria la posizione precisa di un sistema di coordinate)</lI>
        <lI>Il <b>Transporttrolleystate</b>, ossia lo stato attuale del <b>Transport trolley</b>. Formalizzato con l'enumerativo <a href="./ProblemQakSprint3/resources/ws/Transporttrolleystate.kt">Transporttrolleystate.kt</a>:<br>
            <code><pre>enum class Transporttrolleystate { IDLE, MOVING, PICKINGUP, DROPPINGOUT, HALT }</pre></code></lI>
        <lI>Il peso corrente <b>contPB</b> e <b>contGB</b> del materiale contenuto in <b>PLASTICBOX</b> e in <b>GLASSBOX</b></lI>
        <lI>Lo stato corrente del <b>LED</b></lI>
    </ul>
    
</div>

<A NAME="ScrumGoalWorkPlan"></A>
<h2>Scrum Goal and Work Plan</h2>
<div class="remark">
    <h4>Scrum goal:</h4>
    <p>Obiettivo dello SPRINT3 è l'estensione della demo dello <a href="../sprint2/sprint2.html">SPRINT2</a> per realizzare il requisito riguardante la <b>WasteServiceStatusGUI</b> specificato 
        dal committente al punto 3.</p><br>
    <p>Inoltre è necessario pensare ad un piano per la distribuzione, il committente gradirebbe che questo avvenisse con container <a href="./docker_distribution.html">Docker</a>.</p>
    <h4>Piano di lavoro:</h4>
    <ul>
        <li>Analisi del problema riguardo la tipologia di GUI da implementare</li>
        <li>Analisi del problema riguardo il passaggio di informazioni alla GUI</li>
        <li>Sviluppo / adattametno dei componenti necessari</li>
        <li>Realizzazione di un modello eseguibile (a tal proposito verrà utilizzato il metamodello <a href="../docs_common/Qak.html">QAK</a>).</li>
        <li>Realizzazione di un (più completo) test-plan per il modello</li>
    </ul>
</div>

<!--PROBLEM ANALYSIS-->
<A NAME="ProblemAnalysis"></A>
<h2>Problem analysis</h2>
<div class="remark">
    <h6><b>Architettura logica precedente:</b></h6>
    <img class="centerimg" style="max-width: 1300px;" src="../sprint2/QakSprint2/demo0arch.png"/>
    <p style="width: 100%; text-align: right;"><a href="../docs_common/Legenda.html">Legenda</a></p>
    <br>

    <h3><b>GUI</b></h3>

    <h4>Webgui o gui standard</h4>
    <ul>
        <li>
            <p><b>Webgui</b>, con un componente che fa da server web e che risiede su un server aziendale</p>
            <ul>
                <li>+ Gui visualizzabile su qualunqe dispositivo dotato di browser</li>
                <li>+ Riutilizzo di codice disponibile (progetto <a href="../docs_prof/html/webRobot22.html">Webrobot</a>)</li>
                <li>- Necessaria definire l'interazione tra server web e "sistema" (osservare attori tramite CoAP, oppure connettersi come un "<a href="../docs_prof/html/QakIntro.html?highlight=alien#message-delivery-rules">alieno</a>", oppure avviare il server come componente interno ad un attore)</li>
            </ul>
        </li>
        <li>
            <p><b>Gui standard</b> "tradizionare", ossia con un componente da installare sulla workstation nella quale si desidera visualizzare le informazioni della GUI</p>
            <ul>
                <li>+ Non necessita la presenza di un browser (ma oramai la quasi totalità dei dispositivi lo possiede)</li>
                <li>- Necessario installare componenti su ogni dispositivo nel quale viene visualizzata la GUI</li>
            </ul>
            <p>A sua volta abbiamo 2 possibilità</p>
            <ul>
                <li>
                    <p>Si sviluppa un programma "esterno" al sistema, ossia un eseguibile che si connette tramite rete al sistema e avvia una gui sulla workstation</p>
                    <ul>
                        <li>- Necessario definire l'interazione tra server web e "sistema" (osservare attori tramite CoAP, oppure connettersi come un "<a href="../docs_prof/html/QakIntro.html?highlight=alien#message-delivery-rules">alieno</a>")</li>
                    </ul>
                </li>
                <li>
                    <p>Si sviluppa un programma "interno" al sistema, ossia il nodo sul quale è in esecuzione la GUI diventa una parte integrante del sistema, con un attore (ad es. un <a href="../docs_prof/html/QakIntro.html#externalqactor">externalqactor</a>) che riceve/osserva le informazioni e le mostra sulla gui avviata dall'attore</p>
                    <ul>
                        <li>- Viene di fatto aggiunto un nodo al sistema, si ha un nuovo contesto solo per la GUI</li>
                        <li>- Aumenta l'accoppiamento del sistema con la GUI, che è una "external interface", il sistema non dovrebbe dipendere da qualcosa di esterno (vedi <a href="../docs_prof/html/Architetture.html#la-clean-architecture">clean-architecture</a>)</li>
                    </ul>
                </li>
            </ul>
        </li>
    </ul>
    <p>Alla luce di questi raginamenti risulterebbe più conveniente sviluppare una webgui (adattando quella di <a href="../docs_prof/html/webRobot22.html">Webrobot</a>)</p>
    <img class="centerimg" style="max-width: 600px;" src="docs/_images/system-webserver-browser.png"/>

    <h4>Interazione sistema / webserver</h4>
    <p>Si è inizialmente ragionato su due possibilità:</p>
    <ul>
        <li>
            <p>Quella di un attore interno al sistema che osserva (tramite CoAP) tutti gli attori necessari, per poi inviare gli opportuni aggiornamenti al webserver per mezzo di eventi. Il webserver apre una connessione TCP verso i vari contesti per connettersi come "alieno".</p>
            <p>Tuttavia questa modalità di interazione è stata recentemente deprecata dal supporto, dunque l'opzione non è più percorribile (in virtù della prossima modalità di interazione)</p>
        </li>
        <li>
            <p>Il webserver osserva gli attori come risorse CoAP, ricevendo aggiornamenti in merito al loro stato e mostrando di conseguenza le informazioni di interesse</p>
        </li>
    </ul>

    <h4>Il <b>Transporttrolleystate</b> viene calcolato dalla GUI o dal sistema?</h4>
    <p>Transporttrolleystate</b> può essere calcolato:</p>
    <ul>
        <li>
            <p>Dal webserver (quindi esternamente)</p>
            <ul>
                <li>+ Il sistema ha un compito in meno</li>
                <li>- Sistema meno flessibile in caso di future componenti</li>
            </ul>
            <p>Da un attore del sistema (quindi internamente)</p>
            <ul>
                <li>+ Informazione potenzialmente utile per futuri componenti, che risulterà così reperibile anche da essi</li>
            </ul>
        </li>
    </ul>
    <p>Al fine di garantire una futura maggiore estensibilità dell'applicazione si ritiene più opportuno calcolare internamente l'informazione, delegando il compito ad un opportuno attore (<i>transporttrolleystate</i>)</p>



    <div class="remark" style="background-color: #c3fbe8;">
        <h3>Riassunto situazione attuale:</h3>
        <h6>Architettura logica:</h6>
        <img class="centerimg" style="max-width: 1200px;" src="ProblemQakSprint3/demosystemarchitecturearch.png"/>
        <p style="width: 100%; text-align: right;"><a href="../docs_common/Legenda.html">Legenda</a></p>

        <h6>Note</h6>
        <small>Il webserver esterno (o comunque il componente che si occupa di mostrare la gui) viene al momento rappresentato con l'attore <i>servergui</i>: esso dovrà comunque osservare gli attori <i>transporttrolleystate</i>, <i>wasteservice</i>, <i>mover</i> e <i>led</i>.</small>

        <h6>QAK</h6>
        <a href="ProblemQakSprint3/src/Prototype/SystemAchitecture.qak">Modello del sistema QAK</a> <br>
        <h6><p>Testplan <small>(non ancora eseguibili)</small>:</p></h6>
        <p><a href="ProblemQakSprint3/test/testSprint3/TestSprint3_transporttrolleystate.kt">TestSprint3_transporttrolleystate.kt</a> <br>
    </div>

</div>
    


<h2>Project</h2>
<div class="remark">
        <h4>Web robot</h4>
        <p>L'implementazione di <i>WebRobot</i> è stata effettuata mediante l'utilizzo di <a href="../docs_prof/html/WebApplications.html">SpringBoot</a>.<br>
           <i>WebRobot</i> riceve le informazioni mediante l'utilizzo di CoAP, che a sua volta invierà informazioni al front-end mediante l'utilizzo di una WebSocket.</br>
           Più nello specifico, le informazioni che giungono tramite le connessioni CoAP (e che vengono elaborate dagli oggetti 
           <a href="WebRobotKt/src/main/kotlin/unibo/WebRobotKt/ContainerObserver.kt"><i>ContainerObserver</i></a>, <a href="WebRobotKt/src/main/kotlin/unibo/WebRobotKt/PositionObserver.kt"><i>PositionObserver</i></a>, <a href="WebRobotKt/src/main/kotlin/unibo/WebRobotKt/TrasportTrolleyObserver.kt"><i>TrasportTrolleyObserver</i></a>, <a href="WebRobotKt/src/main/kotlin/unibo/WebRobotKt/LedObserver.kt"><i>LedObserver</i></a>) 
           aggiornano un oggetto bean (<a href="WebRobotKt/src/main/kotlin/unibo/WebRobotKt/UpdateGui.kt"><i>UpdateGui</i></a>), che viene poi trasformato in una stringa JSON poi inviata tramite WebSocket a tutti i client attualmente connessi.</p>
        
        <p>Pagina web:</p>
        <img class="centerimg" style="max-width: 1300px;" src="docs/_images/consolegui.png"/>



        <h3>Riassunto situazione attuale:</h3>
        <h6>Architettura logica:</h6>
        <img class="centerimg" style="max-width: 1300px;" src="docs/_images/demo0arch.png"/>
        <p style="width: 100%; text-align: right;"><a href="../docs_common/Legenda.html">Legenda</a></p>


        <h4>problematiche</h4>
        <p>È stato notato, testando il sistema, di come le informazioni CoAP non sempre riuscissero ad essere correttamente visualizzate.<br>
        Per fare fronte a questo problema è stato fatto, in maniera iterativa, una nuova analisi del problema per riuscire a risolvere questa problematica.<br>
        Si è constatata la difficoltà del sistema nel mantenere le connessioni CoAP attive, in particolare alcuni messagi erano vuoti e portavano al blocco della comunicazione.<br>
        È stato quindi necessario riorganizzare la struttura degli attori del sistema.</p>
</div>

<h2>Problem analysis</h2>
<div class="remark">
        <p>Per far fronte alle problematiche riscontrate in precedenza è stato introdotto un nuovo attore, denominato <b>coapdispatcher</b>.<br>
        Quest'ultimo avrà il compito di osservare gli attori transporttrolley,pickupdropouthandler,basicrobotwrapper,mover e, tramite un dispatcher, comunicare con il led ed trasporttrolleystate.<br>
        Mediante questa tecnica gli attori ledalarmcontrol e trasporttrolleystate non osserveranno attori CoAP ma bensì riceveranno dei dispatch.<br>
        In questo modo risulta soltanto un attore in osservazione e genera meno difficoltà nel sistema nella loro comunicazione.</p>

        <div class="remark" style="background-color: #c3fbe8;">
            <h3>Riassunto situazione attuale:</h3>
            <h6>Architettura logica:</h6>
            <img class="centerimg" style="max-width: 1200px;" src="ProblemQakSprint3v2/demosystemarchitecturearch.png"/>
            <p style="width: 100%; text-align: right;"><a href="../docs_common/Legenda.html">Legenda</a></p>
            <h6>QAK</h6>
            <a href="ProblemQakSprint3v2/src/Prototype/SystemAchitecture.qak">Modello del sistema QAK</a> <br>
            <h6><p>Testplan <small>(non ancora eseguibili)</small>:</p></h6>
            <p><a href="ProblemQakSprint3v2/test/testSprint3/TestSprint3_transporttrolleystate.kt">TestSprint3_transporttrolleystate.kt</a> <br>
        </div>
</div>

<h2>Project</h2>
<div class="remark">
    <p>È stato necessario implementare un ulteriore attore, chiamato <b>coapdispatcher</b>, che ha il compito di osservare gli attori transporttrolley, basicrobotwrapper, pickupdropouthandler e mover.<br>
    In questo modo si è potuto avere un solo attore in osservazione, che poi procede ad eseguire un dispatch delle informazioni ottenute a transporttrolleystate e ledalarmcontrol.<br>
    Questo porta ad un minore appesantimento del sistema nella comunicazione CoAP risolvendo le problematiche riscontrate in precedenza.</p><br>

    <div class="remark" style="background-color: #c3fbe8;">
        <h3>Test funzionamento progetto:</h3>
        <video width="1080" class="centerimg" controls>
            <source src="docs/_video/test_working.mp4" type="video/mp4">
        </video>
    </div>
</div>

<h2>Test plans</h2>
<div class="remark">
    <h4><p>Test effettuati:</p></h4>
    <ul>
        <h6>Classe di test TestSprint3_integration_transporttrolleystate.kt:</h6>
        <p>Classe per testare il sistema, in particolare per verificare il funzionamento dell'attore transporttrolleystate</p>
        <li><u>test_accepted()</u>: Il robot viene interrotto durante una move forward, durante una turn, durante una <b>Pickup</b> e una <b>Dropout</b>.
            Si controlla che gli stati delle varie macchine assumano i valori che si si aspetti</li>
      
    </ul>
</div>

<div class="remark" style="background-color: #c3fbe8;">
    <h3>Riassunto situazione attuale:</h3>
    <h6>Architettura logica:</h6>
    <img class="centerimg" style="max-width: 1300px;" src="QakSprint3/demo0arch.png"/>
    <p style="width: 100%; text-align: right;"><a href="../docs_common/Legenda.html">Legenda</a></p>

    <h6>QAK</h6>
    <a href="QakSprint2/src/Prototype/demo0.qak">Metamodello eseguibile QAK</a>
    <h6><p>Testplan:</p></h6>
    <p><a href="QakSprint3/test/testSprint3/TestSprint3_integration_transporttrolleystate.kt">TestSprint3_integration_transporttrolleystate.kt</a> <br>
</div>
 
<!-- USEFUL
<table style="width:100%" border="1">
<tr>
<td style="width:50%">
</td>
<td></td>
</tr>
</table>
-->
	      	
<br/><br/> 	
</div>  

<div style="background-color:rgba(86, 56, 253, 0.9); width:100%;text-align:left;color:white">
    <table style="border: 0px solid transparent; margin: 0 auto;">
        <tr>
            <td>
                <p style="font-weight: bold;">Loris Giannatempo <br>
                Email: loris.giannatempo@studio.unibo.it</p>
                <img class="centerimg" src="../docs_common/lorisgiannatempo.jpg" style="width: 30%; height: 30%; border: 0px">
            </td>
            <td>
                <p style="font-weight: bold;">Davide Guidetti <br>
                Email: davide.guidetti3@studio.unibo.it</p>
                <img class="centerimg" src="../docs_common/davideguidetti.jpg" style="width: 30%; height: 30%; border: 0px">
            </td>
        </tr>
    </table>
</div> 
</body>
</html>