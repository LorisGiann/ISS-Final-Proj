<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
    <!--
<link rel="stylesheet" type="text/css" href="../css/issStyle1.css">
<script type="text/javascript" src="../css/issStyle.js"></script>
-->
<link rel="stylesheet" type="text/css" href="../docs_common/defaultTemplateStyle.css">
<style>
code>pre { 
    font-family: monospace;
}
dd{
    margin-bottom: 7px;
}
.todo{
    color: orange
}
.centerimg{
    display: block;
    padding-top: 8px;
    padding-bottom: 8px;
    margin-left: auto;
    margin-right: auto;
    width: 90%;
    max-width: 800px;
}
p { margin: 4px 0px; }
dd{ margin-bottom: 8px;}
.newDictWord{ color : purple; }
h6{
    font-size: 1em;
    margin: 18px 0px 9px 0px;
}
</style>
<head><title>WasteService SPRINT1</title></head>
    
<body>
<div id="top">
<h1>ISS FINAL PROJECT </h1>
</div>  

<div class="body"> 
<h2>Introduction</h2>
<div class="remark">
    <p>Progetto finale di ISS, che consiste in un impianto di smistamento dei rifiuti nel quale un robot deve trasportare il materiale dal camion al relativo container</p>
</div>

<h2>Requirements</h2>
<div class="remark">
    <a href="../docs_prof/html/TemaFinale22.html">Link alla pagina dei requisiti del committente</a> <br>
    <a href="../sprint0/sprint0.html#Requirements">Requisiti sprint0</a>
</div>

<h2>Requirement analysis</h2>
<div class="remark">
<!--
    <A NAME="Dizionario"></A>
    <h3>Dizionario</h3>
    <p>Vengono qui riportati solo gli elementi nuovi o modificati rispetto al <a href="../sprint0/sprint0.html#Dizionario">dizionario dello sprint0.</a></p>
    <p>Vengono segnati in <b class="newDictWord">viola</b> i termini non presenti nei requisiti, ma introdotti in quanto utilizzati all'interno dei documenti prodotti</p>
    <p>La formalizzazione avviene quando possibile con costrutti del linguaggio <a href="https://kotlinlang.org/">Kotlin</a>, mentre quando opportuno verrà utilizzato <a href="../docs_common/Qak.html">QAK</a></p>
    <dl>
        <dt><b>Transport trolley:</b></dt>
        <dd>In seguito alla relativa <a href="#DDR_robot_vs_Transport_trolley">analisi del problema</a> di questo sprint, <b>Transport trolley</b> rappresenta un'entità robotica astratta che riceve i comandi di alto livello relativi alla prossima destinazione da raggiungere, e i comandi di <b>Pickup</b> e <b>Dropout</b>.<br>
            Nota: il <b>Transport trolley</b> può ricevere una richiesta di spostamento su nuova posizione prima che abbia raggiunto la destinazione precedente: la navigazione sarà impostata sulla nuova destinazione. In questo modo è possibile soddisfare direttamente una nuova richiesta anche se essa arriva mentre il robot sta tornando in home.<br>
            Formalizzazione: 
            <code><pre>
//POSITION = INDOOR | PLASTICBOX | GLASSBOX | HOME
//RESULT =  OK | ERROR
Request moveto         : moveto(POSITION)  //INDOOR | PLASTICBOX | GLASSBOX | HOME
Reply   movetoanswer   : movetoanswer(RESULT)
Request pickup         : pickup(_)
Reply   pickupanswer   : pickupanswer(RESULT)
Request dropout        : dropout(_)
Reply   dropoutanswer  : dropoutanswer(RESULT)</pre>
            </code>
            File QAK <a href="./ProblemQakSprint1/src/problemAnalysis/TransportTrolleyRequirement.qak">TransportTrolleyRequirement.qak</a></b>. Test per meglio specificarne il comportamento: <a href="./ProblemQakSprint1/test/testSprint1/TestTransporttrolley.kt">TestTransporttrolley.kt</a>.
        </dd>
    </dl>
-->
</div>

<A NAME="ScrumGoalWorkPlan"></A>
<h2>Scrum Goal and Work Plan</h2>
<div class="remark">
    <h4>Scrum goal:</h4>
    <p>Obiettivo dello SPRINT1 è la creazione di una prima demo (su ambiente virtuale) che tenga presente dei soli punti 1 e 2 specificati dal committente, siccome sono i punti principali che 
        contengono la core business logic del problema (descrivono infatti la <b>Service area</b> e le <b>Deposit action</b>)</p>
    <h4>Piano di lavoro:</h4>
    <ul>
        <li>Analisi del problema di come affrontare la navigazione, anche in relazione al SW già sviluppato <br>
            (possibile visitare la pagina riassuntiva <a href="../docs_prof/html/Applicazioni22.html">Applicazioni22</a> dei moduli sviluppati)</li>
        <li>Analisi delle responsabilità e delle interazioni tra i componenti <i>wasteservice</i>, <i>trasporttrolley</i> e <i>basicrobot</i></li>
        <li>Sviluppo / adattamento di tali componenti</li>
        <li>Realizzazione di un modello eseguibile (a tal proposito verrà utilizzato il metamodello <a href="../docs_common/Qak.html">QAK</a>).</li>
        <li>Realizzazione di un (più completo) test-plan per il modello</li>
    </ul>
</div>

<!--PROBLEM ANALYSIS-->
<A NAME="ProblemAnalysis"></A>
<h2>Problem analysis</h2>
<div class="remark">
    <h6><b>Architettura logica precedente:</b></h6>
    <img class="centerimg" style="width: 450px;" src="./docs/_images/logic_architecture_0.png"/>
    <p style="width: 100%; text-align: right;"><a href="../docs_common/Legenda.html">Legenda</a></p>
    <br>

    <h3><b>Wasteservice</b></h3>

    <h4>Quando rispondere allo <b>Smart device</b>?</h4>
    <p>Siccome i requisiti aggiuntivi dicono che sarebbe bene mandare via il <b>Waste-truck</b> appena possibile, se una richiesta può essere soddisfatta il driver deve essere liberato subito dopo il <b>Pickup</b> (inviando allo <b>Smart device</b> una <b>loadaccept</b>). 
        Se invece la richiesta effettuata non può essere soddisfatta, è bene rispondere immediatamente con una <b>loadrejected</b> (qualunque cosa stia facendo il robot in quel momento).</p>

    <h3><b>Transport trolley</b></h3>

    <h4 id="DDR_robot_vs_Transport_trolley"><b>DDR robot</b> vs <b>Transport trolley</b>:</h4>
    <ul>
        <p>Possibile una separazione dei due concetti: </p>
        <li>
            Il termine "DDR - Differential Drive Robot" rappresenta la tecnologia con la quale il robot si muove. Il <b>DDR robot</b> è quindi una entità di basso livello che riceve comandi base come "avanti", "destra", "sinistra", "halt", ecc.. <br>
            Possiamo quindi identificare il <b>DDR robot</b> come l'attore QAK <a href="../sprint0/RequirementQakSprint0/src/requirementAnalysis/BasicRobotRequirement.qak"><i>basicrobot</i></a> presente in <a href="https://github.com/anatali/issLab2022/tree/main/unibo.basicrobot22">unibo.basicRobot22</a>, che infatti riceve comandi:
            <code><pre>
//MOVE =  w | a | s | d | h    | l | r
Dispatch cmd           : cmd(MOVE)</pre>
            </code>
        </li>
        <li>
            Invece il <b>Transport trolley</b> è concepita come entità astratta di più alto livello che si occuperà di ricevere la destinazione generica<br>
            <code><pre>
//POSITION =  INDOOR | PLASTICBOX | GLASSBOX | HOME
Request moveto         : moveto(POSITION)
Reply   movetoanswer   : movetoanswer(RESULT)</pre>
            </code>
        </li>
    </ul>
    <b>Transport trolley</b> invierà quindi una serie di comandi elementari a <b>DDR robot</b> per raggiungere la nuova posizione. <br>
    La relazione che esiste tra <b>WasteService</b> e <b>Transport trolley</b> è quindi di tipo "use". <br>
    Questa separazione in due layer rende il sistema più resistente ad eventuali future variazioni della tecnologia utilizzata per il robot (movimento a step con coordinate o meno, tipologia di hardware del robot). 
    Il <b>WasteService</b> continuerà ad inviare al <b>Transport trolley</b> gli stessi comandi astratti, senza preoccuparsi di "in che modo" o "con quali mezzi" la destinazione viene raggiunta.

    <h4>Dove collocare <b>Transport trolley</b>:</h4>
    Risulta concettualmente sensato porre <b>Transport trolley</b> nello stesso contesto di <i>basicrobot</i>.<br>
    <b>Transport trolley</b> potrebbe infatti necessitare di cambiamenti nel caso in cui cambi il <b>DDR Robot</b> e la tecnologia di movimento usata. <br>
    Si noti tuttavia che, qualora tale componente debba fare utilizzo di un planner (che effettua una ricerca nello spazio degli stati), allora si dovrebbe considerare la possibilità 
    di porre tale attore su un nodo computazionale più potente, dove il consumo di potenza non è un problema (mentre si presume che il robot sia alimentato a batteria). <br>
    Alla luce delle osservazioni sinora fatte, l'architettura logica attuale è la seguente:
    <img class="centerimg" style="width: 500px;" src="docs/_images/logic_architecture_1.png"/>
    <p style="width: 100%; text-align: right;"><a href="../docs_common/Legenda.html">Legenda</a></p>

    <h4>Operazioni eseguite dal <b>Transport trolley</b>:</h4>
    <p>Per questioni di flessibilità, sarebbe opportuno comandare al <b>Transport trolley</b> separatamente le operazioni di carico, scarico e movimento. <br>
        In questo modo se dovesse cambiare il processo di smistamento basterà modificare la sequenza di comandi che vengono impartiti al <b>Transport trolley</b>, senza bisogno di 
        modificare quest'ultimo. Inoltre si ritiene corretto far gestire al <b>Transport trolley</b> le operazioni di <b>Pickup</b> e <b>Dropout</b>, siccome un domani potrebbe esser 
        necessario inviare comandi o segnali a HW presente sul robot per compiere queste azioni.</p>
    <p>Le interazioni con il <b>Transport trolley</b> dovrebbero essere di tipo request-response sincrone bloccanti. 
        Tuttavia, solo per il comando <i>moveto(POSITION)</i>, dovrà essere possibile comandare una nuova destinazione anche se quella precedente non era stata ancora raggiunta (annullando di fatto la <i>moveto</i> precedente)<br>
        Questo perchè è possibile che arrivi un nuovo <b>Waste-truck</b> mentre il <b>Transport trolley</b> sta tornando ad <b>HOME</b>. In questo modo è possibile la gestione immediata 
        della nuova richiesta senza aspettare che il <b>Transport trolley</b> raggiunga <b>HOME</b>.
    </p>
    <p>L'interfaccia del transporttrolley risulta quindi essere la seguente:</p>
    <code><pre>
        //POSITION = INDOOR | PLASTICBOX | GLASSBOX | HOME
        //RESULT =  OK | ERROR
        Request moveto         : moveto(POSITION)  //INDOOR | PLASTICBOX | GLASSBOX | HOME
        Reply   movetoanswer   : movetoanswer(RESULT)
        Request pickup         : pickup(_)
        Reply   pickupanswer   : pickupanswer(RESULT)
        Request dropout        : dropout(_)
        Reply   dropoutanswer  : dropoutanswer(RESULT)</pre>
    </code>
    Si veda il file QAK <a href="./ProblemQakSprint1/src/problemAnalysis/TransportTrolley.qak">TransportTrolley.qak</a></b>. È anche disponibile un test per meglio specificarne il comportamento: <a href="./ProblemQakSprint1/test/testSprint1/TestTransporttrolley.kt">TestTransporttrolley.kt</a>.

    <h4>Il problema della navigazione: <br>
        <p>Uso di un sistema di coordinate  o  boundary walker che raggiunge gli angoli rilevando il contatto con i muri?</p>
    </h4>
    <p>La particolare collocazione delle zone <b>INDOOR</b>, <b>PLASTICBOX</b>, <b>GLASSBOX</b>, <b>HOME</b> e la presenza di un sonar o sensore di impatto sul robot rendono attuabile una 
        soluzione che non richiede l'utilizzo di coordinate: 
        il robot può infatti muoversi all'interno della <b>Service area</b> lungo le pareti, orientandosi semplicemente rilevando le collisioni con le pareti. <br>
        In questa sezione analizziamo i punti a favore dell'utilizzo di un sistema a coordinate e uno senza coordinate:</p>
    <br>

    <p>I vantaggi nell'utilizzo di un sistema a coordinate:</p>
    <ul>
        <li>Maggiore flessibilità. Ad esempio nel caso in cui la posizione dei siti non sia più negli angoli, o il robot debba seguire un percorso ottimo, o se ci sono ostacoli nella <b>Service area</b>, ecc... .</li>
        <li>Potenziale riuso di moduli che già abbiamo sviluppato (mapper, planner)</li>
    </ul>
    <p>I vantaggi nell'utilizzo di un sistema senza coordinate:</p>
    <ul>
        <li>Minor complessità, minor costo</li>
        <li>Maggior velocità negli spostamenti, e maggior velocità di reazione a comandi di halt mentre ci si muove in avanti (non si deve aspettare di aver terminato uno step)</li>
        <li>Possibile miglior reazione da parte di robot reali che non fanno uso di sistemi in feedback o altro hardware per controllare meglio i propri spostamenti: <br>
            L'errore potrebbe aumentare ad ogni singolo step, mentre la prima soluzione (siccome utilizza un sensore di contatto con il muro) non soffre di questo problema</li>
    </ul>
    <br>
    <p>Per scegliere in merito ad una decisione così importante, sono state analizzate diverse opzioni, che vengono descritte in </p>
    <p style="width: 100%; text-align: center; padding: 1rem"> <a href="docs/grid_or_boundary_analysis.html"><mark>grid_or_boundary_analysis.html</mark></a> </p>
    <p>Come riportato nel relativo documento, optiamo per l'utilizzo di una soluzione senza utilizzo di coordinate, facendo solamente uso di una FSM</p>

    <div class="remark" style="background-color: #c3fbe8;">
        <h3>Riassunto situazione attuale:</h3>
        <h6>Architettura logica:</h6>
        <img class="centerimg" style="max-width: 1000px;" src="ProblemQakSprint1/demosystemarchitecturearch.png"/>
        <p style="width: 100%; text-align: right;"><a href="../docs_common/Legenda.html">Legenda</a></p>
        <h6>QAK</h6>
        <a href="ProblemQakSprint1/src/problemAnalysis/SystemAchitecture.qak">Modello del sistema QAK</a> <br>
        <a href="ProblemQakSprint1/src/problemAnalysis/WasteService.qak">Primo metamodello QAK <i>wasteservice</i></a> <small>(= a sprint0)</small><br>
        <a href="ProblemQakSprint1/src/problemAnalysis/TransportTrolley.qak">Primo metamodello QAK <i>transporttrolley</i></a> <br>
        <h6><p>Testplan:</p></h6>
        <p><a href="ProblemQakSprint1/test/testSprint1/TestWasteservice.kt">TestWasteservice.kt</a> <small>(= a sprint0)</small><br>
            <a href="ProblemQakSprint1/test/testSprint1/TestTransporttrolley.kt">TestTransporttrolley.kt</a></p>
    </div>

</div>
    


<h2>Project</h2>
<div class="remark">
    <p>Procediamo con lo sviluppo vero e proprio dei componenti. Essi sono tutti presenti nel <a href="QakSprint1/src/Prototype/demo0.qak">file QAK di questo sprint</a>, ma vengono qui riportate e spiegate le macchine a stati che li implementano.</p>
    

    <h3><b>Transport trolley</b></h3>
    <p>Iniziamo con il <b>Transport trolley</b>, uno dei punti di maggior interesse nell'ambito di questo sprint. <br>
        Come evidenziato in analisi del problema, è opportuno poter comandare al <b>Transport trolley</b> separatamente le operazioni di carico, scarico e movimento. <br>
        Allo stesso tempo sarebbe però bene mantenere separate la parte che implementa la navigazione del robot verso la prossima destinazione dalla parte che implementa le azioni di 
        <b>Pickup</b> e <b>Dropout</b>. Per questo motivo si è scelto di far sì che il <i>trasporttrolley</i> funga da semplice "dispatcher" di comandi verso 2 componenti che si occupano
        separatamente di implementare separatamente i due aspetti prima citati:</p>
    <ul>
        <li>
            <p>Attore <i>pickupdropouthandler</i> per implementare le operazioni di <b>Pickup</b> e <b>Dropout</b>. Interfaccia:</p>
            <code><pre>
//RESULT =  OK | ERROR
Request pickup         : pickup(_)
Reply   pickupanswer   : pickupanswer(RESULT)
Request dropout        : dropout(_)
Reply   dropoutanswer  : dropoutanswer(RESULT)</pre>
            </code>
        </li>
        <li>
            <p>Attore <i>mover</i> per implementare la logica di navigazione del robot verso la prossima destinazione. Interfaccia:</p>
            <code><pre>
//POSITION =  INDOOR | PLASTICBOX | GLASSBOX | HOME
Request move           : move(POSITION)
Reply   moveanswer     : moveanswer(RESULT)</pre>
            </code>
        </li>
    </ul>

    <p>Inoltre, al fine di uniformare i comandi che vengono inviati verso il robot, è utile introdurre un "wrapper" al <i>basicrobot</i> che esponga solo comandi sincroni bloccanti all'esterno. 
        In particolare il wrapper si occupa di rispondere al comando di andata avanti solo quando si vede arrivare l'evento <i>info</i> da <i>basicrobot</i>. <br>
        <i>Basicrobotwrapper</i> riceverà e risponderà con messaggi del tipo:</p>
        <code><pre>
//RESULT =  OK | ERROR 
//MOVE =  w | l | r | h 
Request cmdsync   	: cmdsync(MOVE)
Reply cmdanswer   	: cmdanswer(RESULT)</pre>
        </code>
        <p>La scelta di introdurre questo componente potrebbe poi rilevarsi strategica per la gestione dell'halt quando la distanza misurata dal <b>Sonar</b> è ≤ DLIMT. <br>
            Potremmo infatti introdurre a questo livello due operazioni che bloccano e fanno riprendere al robot la mossa attualmente in esecuzione, il tutto in maniera trasparente ai 
            componenti di più alto livello. Esploreremo meglio questa opportunità negli sprint successivi.<p>
        <p>L'architettura diventa quindi come segue: </p>
    <img class="centerimg" style="width: 700px;" src="docs/_images/logic_architecture_2.png"/>
    <p style="width: 100%; text-align: right;"><a href="../docs_common/Legenda.html">Legenda</a></p>

    <p>Visitiamo ora nel dettaglio le implementazioni dei nuovi componenti:</p>

    <h4><i>trasporttrolley</i></h4>
    <p>Come anticipato, si tratta di un semplice dispatcher di comandi. Si noti come per l'operazione di <i>move</i> sia possibile comandare una nuova <i>move(POS)</i> senza che la precedente sia necessariamente terminata.</p>
    <img class="centerimg" style="max-width: 550px;" src="./docs/_images/transporttrolley_state_machine.png"/>

    <h4><i>mover</i></h4>
    <p>Siccome lo sviluppo di questo componente risulta essere piuttosto denso e articolato, viene trattato separatamente in una pagina a parte:</p>
    <p style="width: 100%; text-align: center; padding: 1rem"> <a href="docs/mover_project.html"><mark>mover_project.html</mark></a> </p>
    <!--
    <p>La logica di base del componente rimane quella analizzata nell'opzione 1 di <a href="docs/grid_or_boundary_analysis.html">grid_or_boundary_analysis</a>. Tuttavia per poterlo implementare efficacemente con QAK la struttura è stata riorganizzata nel seguente modo:</p>
    <img class="centerimg" style="max-width: 800px;" src="./docs/_images/mover_actor_state_diagram_1.png"/>
    <p>In particolare lo stato <i>handle</i> conterrà un blocco onMsg() che permetterà di settare la variabile di destinazione solo quando arriva un messaggio <i>move(POS)</i>, mentre la guardia 
        permetterà di capire se è necessario continuare per raggiungere la prossima <b>Position</b> o fermarsi. Inoltre la transizione che va da <i>reply</i> a <i>wait</i> potrebbe avvenire sia in assenza 
        di messaggi (transizione spontanea), sia consumando un ulteriore messaggio <i>move(POS)</i>, il che avviene quando si cambia la destinazione prima ancora di aver raggiunto quella precedente.</p>
    <p>La macchina a stati completa sarebbe quindi la seguente:</p>
    <img class="centerimg" style="max-width: 800px;" src="./docs/_images/mover_actor_state_diagram_2.png"/>
    -->

    <h4><i>pickupdropouthandler</i></h4>
    <p>Si tratta di un componente il cui compito è semplicemente quello di contenere le routine di gestione delle operazioni di <b>Pickup</b> e <b>Dropout</b> (che attualmente consistono semplicemente in delle delay).</p>
    <img class="centerimg" style="max-width: 300px;" src="./docs/_images/pickupdropouthandler_state_machine.png"/>

    <h4><i>basicrobotwrapper</i></h4>
    <p>Un semplice wrapper che permette di comandare il robot facendo uso di semplici comandi sincroni bloccanti. Per il comando di andata avanti (<i>cmdsync(w)</i>) la risposta viene ricevuta dopo 
        aver rilevato l'impatto con il muro (evento <i>info</i>). È anche possibile interrompere l'andata avanti per inviare un altro comando (necessario per fare inversione ad U) </p>
    <img class="centerimg" style="max-width: 750px;" src="./docs/_images/basicrobotwrapper_state_machine.png"/>
    
    


    <h3><b>WasteService</b></h3>
    <p>Il <b>WasteService</b> contiene buona parte della business logic del sistema. Possiamo identificare due "macro-parti" di questo servizio, che abbiamo diviso in 2 distinti attori:</p>
    <ul>
        <li>La prima è quella che si occupa di ricevere le richieste, vedere se è possibile prendere in carico il materiale e mantenere aggiornati i volumi presenti all'interno dei container (di questo se ne occupa l'attore <i>wasteservice</i>)</li>
        <li>La seconda è quella che invia i comandi per effettuare la <b>Deposit action</b> (compito delegato all'attore <i>depositaction</i>).</li>
    </ul>
    <p>Architettura:</p>
    <img class="centerimg" style="max-width: 700px;" src="docs/_images/logic_architecture_3.png"/>
    <p style="width: 100%; text-align: right;"><a href="../docs_common/Legenda.html">Legenda</a></p>

    <p>Viene riportato il diagramma degli stati di <i>wasteservice</i> e <i>depositaction</i>. </p> 
    <br>
    <h4><i>wasteservice</i></h4>
    <img class="centerimg" style="max-width: 700px;" src="docs/_images/wasteservice_actor_state_diagram_1.png"/>
    <p><i>Wasteservice</i> rimane in attesa di nuove richieste quando è nello stato wait. Quando arriva la prima richiesta si decide se viene accettata o meno (stato <i>handle_req</i>). Se viene 
        accettata si richiede all'attore <i>depositaction</i> di effettuare l'operazione (stato <i>req_depositaction</i>) e si attende la risposta <i>pickupdone</i>. Il truck riceve la <b>loadaccept</b> 
        subito dopo il completamento del <b>Pickup</b> (stato <i>chk_depositaction</i>). <br>
        Se invece (nello stato <i>chk_depositaction</i>) ci si rende conto che non c'è spazio, il truck riceve <b>loadrejected</b> (stato <i>rejected</i>) subito dopo aver fatto la richiesta.</p>
    <br>
    <h4><i>depositaction</i></h4>
    <img class="centerimg" style="max-width: 1000px;" src="docs/_images/depositaction_actor_state_diagram_1.png"/>
    <p>Quando arriva una richiesta di <b>Deposit action</b>, il robot viene inviato in <b>INDOOR</b>, effettua la <b>Pickup</b>, risponde con <i>pickupdone</i> a <i>wasteservice</i>, si posiziona 
        sul container di destinazione ed effettua la <b>Dropout</b>. Poi controlla che non vi siano altre richieste (stato <i>next_move</i>), se non ci sono si sposta verso <b>HOME</b> (stato 
        <i>move_home</i>), altrimenti le gestisce subito. Se mentre ci si sta muovendo verso <b>HOME</b> arriva una nuova richiesta, questa viene gestita immediatamente.
    </p>
    <br>
    <p>Vengono qui mostrati anche gli stati che servono per controllare l'esito dell'operazione e lo stato di errore:</p>
    <img class="centerimg" style="max-width: 1150px;" src="./docs/_images/depositaction_actor_state_diagram_2.png" />

    <h4>note: <i>wasteservice/depositaction</i></h4>
    <p>Si noti come <i>wasteservice</i> sia pronto per elaborare una nuova richiesta non appena gli arriva da <i>depositaction</i> la risposta <i>pickupdone</i>. <i>Wasteservice</i> può quindi 
        elaborare parzialmente nuove richieste prima ancora che il robot abbia finito di gestire quella precedente (potenzialmente già dalla conclusione della <b>Pickup</b> della richiesta attualmente in gestione).<br>
        Nello specifico, se non sarebbe comunque possibile soddisfare tale richiesta, viene inviata una <b>loadrejected</b> e si analizza la prossima richiesta.
        Se invece la richiesta può essere soddisfatta, <i>wasteservice</i> invierà la richiesta di <i>depositaction</i> verso l'omonimo attore, tuttavia questo gli risponderà con una <i>pickupdone</i> solo quando verrà fatta la <b>Pickup</b> relativa alla nuova richiesta.
        Quindi, nel caso di due richieste consecutive che possono essere entrambe soddisfatte, la FSM di <i>wasteservice</i> aspetterà nello stato <i>req_depositaction</i> prima di poter processare 
        (anche solo parzialmente) una terza richiesta: essa verrebbe infatti accodata nella coda interna dell'attore</p>
    
</div>


<h2>Test plans</h2> 
<div class="remark">
    <p>Per il <b>Test plan</b> sono state definite le classi di test JUnit <a href="QakSprint1/test/testSprint1/TestSprint1_wasteservice.kt">TestSprint1_wasteservice</a>, 
        <a href="QakSprint1/test/testSprint1/TestSprint1_mover.kt">TestSprint1_mover</a> e <a href="QakSprint1/test/testSprint1/TestSprint1_integration_test.kt">TestSprint1_integration_test</a> </p>
    <p>Per un testing adeguato, viene sfruttata la possibilità di rendere gli attori osservabili mediate CoAP. I test registrano sistematicamente ogni cambiamento di stato degli attori osservati, dopo di che 
        si controlla che la sequenza di cambiamenti di stato sia compatibile con quello che ci si aspetta che accada. Al fine di rendere il testing più agevole sono state realizzate le classi di utilità
        <a href="QakSprint1/test/testSprint1/TestObserver.kt">TestObserver</a> e <a href="QakSprint1/test/testSprint1/TestUtils.kt">TestUtils</a>.</p>

    <h4><p>Test effettuati:</p></h4>
    <ul>
        <h6>Classe di test TestSprint1_wasteservice.kt:</h6>
        <p>Si tratta essenzialmente degli stessi test già individuati in fase di analisi dei requisiti</p>
        <li><u>test_2_accepted()</u>: Invio al <i>wasteservice</i> di due richieste, che devono essere accettate</li>
        <li><u>test_1_accepted_1_rejected()</u>: Invio al <i>wasteservice</i> di due richieste, la prima deve essere accettata, la seconda no per mancanza di spazio</li>
        <h6>Classe di test TestSprint1_integration_test.kt:</h6>
        <p>Verifica i cambiamenti di stato che avvengono negli attori <i>wasteservice</i>, <i>depositaction</i>, <i>transporttrolley</i>, <i>pickupdropouthandler</i> e <i>mover</i>.</p>
        <lI><u>test_accepted()</u>: Test singola richiesta che deve essere accettata</lI>
        <li><u>test_rejected()</u>: Test singola richiesta che deve essere rifiutata</li>
        <li><u>test_2_accepted_while_in_operation()</u>: Test due richieste (la seconda inviata appena iniziate le operazioni di <b>Dropout</b> della richiesta precedente): il robot va direttamente in INDOOR per soddisfare la seconda richiesta, che viene accettata</li>
        <li><u>test_1_accepted_1_rejected_while_in_operation()</u>: Test due richieste (la seconda inviata appena iniziate le operazioni di <b>Dropout</b> della richiesta precedente): il robot va comunque in HOME, siccome la seconda richiesta deve essere rifiutata</li>
        <li><u>test_2_accepted_while_returning_home()</u>: Test due richieste (la seconda inviata mentre il robot stava tornando a casa): il robot deve reimpostare la sua destinazione verso INDOOR per soddisfare la seconda richiesta, che viene accettata</li>
        <li><u>test_1_accepted_1_rejected_while_returning_home()</u>: Test due richieste (la seconda inviata mentre il robot stava tornando a casa): il robot deve continuare ad andare verso HOME, siccome la seconda richiesta deve essere rifiutata</li>
        <h6>Classe di test TestSprint1_mover.kt:</h6>
        <p>Unit testing per l'attore mover.</p>
        <lI><u>test_from_H_to_H()</u>: test nessuna mossa necessaria</lI>
        <lI><u>test_from_H_to_I()</u>: test movimento senso antiorario</lI>
        <lI><u>test_from_PB_to_I()</u>: test movimento senso orario</lI>
        <lI><u>test_from_I_to_GB()</u>: test movimento senso antiorario (2 fermate)</lI>
        <lI><u>test_new_pos_no_chenage_route_from_GB_to_H_then_I()</u>: test settaggio nuova posizione mentre è in forward: nessuna inversione ad U necessaria</lI>
        <lI><u>test_new_pos_chenage_route_from_PB_to_H_then_I()</u>: test settaggio nuova posizione mentre è in forward: necessaria inversione ad U</lI>

    </ul>

</div>

<div class="remark" style="background-color: #c3fbe8;">
    <h3>Riassunto situazione attuale:</h3>
    <h6>Architettura logica:</h6>
    <img class="centerimg" style="max-width: 700px;" src="docs/_images/logic_architecture_3.png"/>
    <p style="width: 100%; text-align: right;"><a href="../docs_common/Legenda.html">Legenda</a></p>
    <h6>QAK</h6>
    <a href="QakSprint1/src/Prototype/demo0.qak">Metamodello eseguibile QAK</a>
    <h6><p>Testplan:</p></h6>
    <p><a href="QakSprint1/test/testSprint1/TestSprint1_wasteservice.kt">TestSprint1_wasteservice.kt</a> <small>(= a sprint0)</small> <br>
        <a href="QakSprint1/test/testSprint1/TestSprint1_mover.kt">TestSprint1_mover.kt</a> <br>
        <a href="QakSprint1/test/testSprint1/TestSprint1_integration_test.kt">TestSprint1_integration_test.kt</a></p>
</div>
 
<!-- USEFUL
<table style="width:100%" border="1">
<tr>
<td style="width:50%">
</td>
<td></td>
</tr>
</table>
-->
	      	
<br/><br/> 	
</div>  

<div style="background-color:rgba(86, 56, 253, 0.9); width:100%;text-align:left;color:white">
    <table style="border: 0px solid transparent; margin: 0 auto;">
        <tr>
            <td>
                <p style="font-weight: bold;">Loris Giannatempo <br>
                Email: loris.giannatempo@studio.unibo.it</p>
                <img class="centerimg" src="../docs_common/lorisgiannatempo.jpg" style="width: 30%; height: 30%; border: 0px">
            </td>
            <td>
                <p style="font-weight: bold;">Davide Guidetti <br>
                Email: davide.guidetti3@studio.unibo.it</p>
                <img class="centerimg" src="../docs_common/davideguidetti.jpg" style="width: 30%; height: 30%; border: 0px">
            </td>
        </tr>
    </table>
</div> 
</body>
</html>