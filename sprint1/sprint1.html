<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
    <!--
<link rel="stylesheet" type="text/css" href="../css/issStyle1.css">
<script type="text/javascript" src="../css/issStyle.js"></script>
-->
<link rel="stylesheet" type="text/css" href="../docs_common/defaultTemplateStyle.css">
<style>
code>pre { 
    font-family: monospace;
}
dd{
    margin-bottom: 7px;
}
.todo{
    color: orange
}
.centerimg{
    display: block;
    padding-top: 8px;
    padding-bottom: 8px;
    margin-left: auto;
    margin-right: auto;
    width: 90%;
    max-width: 800px;
}
p { margin: 4px 0px; }
dd{ margin-bottom: 8px;}
.newDictWord{ color : purple; }
h6{
    font-size: 1em;
    margin: 18px 0px 9px 0px;
}
</style>
<head>
   
<title>WasteService SPRINT1</title></head>
    
<body>
<div id="top">
<h1>ISS FINAL PROJECT </h1>
</div>  

<div class="body"> 
<h2>Introduction</h2>
<div class="remark">
    <p>Progetto finale di ISS, che consiste in un impianto di smistamento dei rifiuti nel quale un robot deve trasportare il materiale dal camion al relativo container</p>
</div>

<h2>Requirements</h2>
<div class="remark">
    <a href="../docs_prof/html/TemaFinale22.html">Link alla pagina dei requisiti del committente</a> <br>
    <a href="../sprint0/sprint0.html#Requirements">Requisiti sprint1</a>
</div>

<h2>Requirement analysis</h2>
<div class="remark">
    <A NAME="Dizionario"></A>
    <h3>Dizionario</h3>
    <p>Vengono qui riportati solo gli elementi nuovi o modificati rispetto al <a href="../sprint0/sprint0.html#Dizionario">dizionario dello sprint0.</a></p>
    <p>Vengono segnati in <span class="newDictWord"><b>viola</b></span> i termini non presenti nei requisiti, ma introdotti in quanto utilizzati all'interno dei documenti prodotti</p>
    <p>La formalizzazione avviene quando possibile con costrutti del linguaggio <a href="https://kotlinlang.org/">Kotlin</a>, mentre quando opportuno verrà utilizzato <a href="#Qak">QAK</a></p>
    <dl>
        <dt><b>Transport trolley:</b></dt>
        <dd>In seguito alla relativa <a href="#DDR_robot_vs_Transport_trolley">analisi del problema</a> di questo sprint, <b>Transport trolley</b> rappresenta un'entità robotica astratta che riceve i comandi di alto livello relativi alla prossima destinazione da raggiungere, e i comandi di <b>Pickup</b> e <b>Dropout</b>.<br>
            Nota: il <b>Transport trolley</b> può ricevere una richiesta di nuova posizione prima che abbia raggiunto la destinazione precedente: la navigazione sarà impostata sulla nuova destinazione. In questo modo è possibile soddisfare direttamente nuove richieste anche mente il robot sta andando in home.<br>
            Formalizzazione: 
            <code><pre>
//POSITION = INDOOR | PLASTICBOX | GLASSBOX | HOME
//RESULT =  OK | ERROR
Request move           : move(POSITION)    
Reply   moveanswer     : moveanswer(RESULT)
Request pickup         : pickup(_)
Reply   pickupanswer   : pickupanswer(RESULT)
Request dropout        : dropout(_)
Reply   dropoutanswer  : dropoutanswer(RESULT)</pre>
            </code>
            File QAK <a href="./RequirementQakSprint1/src/requirementAnalysis/TransportTrolleyRequirement.qak">TransportTrolleyRequirement.qak</a></b>. Test per meglio specificarne il comportamento: <a href="./RequirementQakSprint1/test/testSprint1/TestTransporttrolley.kt">TestTransporttrolley.kt</a>.
        </dd>
    </dl>
</div>

<A NAME="ScrumGoalWorkPlan"></A>
<h2>Scrum Goal and Work Plan</h2>
<div class="remark">
    <h4>Scrum goal:</h4>
    <p>Obiettivo dello <u>SPRINT1</u> è la creazione di una prima demo (su ambiente virtuale) che tenga presente dei soli punti 1 e 2 specificati dal committente, i punti principali che contengono la core business logic del problema (descrivono infatti le <b>Deposit action</b> e la <b>Service area</b>)</p>
    <h4>Piano di lavoro:</h4>
    <ul>
        <li>Analisi del problema di come affrontare la navigazione, anche in relazione al SW già sviluppato (possibile visitare la pagina riassuntiva <a href="../docs_prof/html/Applicazioni22.html">Applicazioni22</a> dei moduli sviluppati)</li>
        <li>Analisi di quali e quanti componenti è composto il problema, e definizione delle interazioni tra di essi</li>
        <li>Sviluppo / adattamento di tali componenti</li>
        <li>Realizzazione di un modello eseguibile (a tal proposito verrà utilizzato il metamodello <a href="../docs_common/Qak.html">QAK</a>).</li>
        <li>Realizzazione di un (più completo) test-plan per il modello</li>
    </ul>
</div>

<!--PROBLEM ANALYSIS-->
<A NAME="ProblemAnalysis"></A>
<h2>Problem analysis</h2>
<div class="remark">
    <h6><b>Architettura logica precedente:</b></h6>
    <img class="centerimg" style="width: 450px;" src="./docs/_images/logic_architecure_0.png"/>
    <p style="width: 100%; text-align: right;"><a href="../docs_common/Legenda.html">Legenda</a></p>
    <br>

    <h3><b>Transport trolley</b></h3>

    <h4 id="DDR_robot_vs_Transport_trolley"><b>DDR robot</b> vs <b>Transport trolley</b>:</h4>
    <ul>
        <li>
            Possibile una separazione dei due concetti: <br>
            Il termine "DDR - Differential Drive Robot" rappresenta la tecnologia con la quale il robot si muove. Il <b>DDR robot</b> è quindi una entità di basso livello che riceve comandi base come "anvanti", "destra", "sisnitra", "halt", ecc.. <br>
            Possiamo quindi identificare il <b>DDR robot</b> come l'attore QAK <a href="https://github.com/anatali/issLab2022/blob/main/unibo.basicrobot22/src/basicrobot.qak"><i>basicrobot</i></a> presente nel progetto <i>basicrobot22</i>, che infatti riceve comandi:
            <code><pre>
//MOVE =  w | a | s | d | h
Dispatch cmd           : cmd(MOVE)</pre>
            </code>
        </li>
        <li>
            Invece il <b>Transport trolley</b> è concepita come entità astratta di più alto livello che si occpura di ricevere la destinazione generica<br>
            <code><pre>
//POSITION =  INDOOR | PLASTICBOX | GLASSBOX | HOME
Request move           : move(POSITION)
Reply   moveanswer     : moveanswer(RESULT)</pre>
            </code>
        </li>
    </ul>
    <b>Transport trolley</b> invierà quindi una serie di comandi elementari a <b>DDR robot</b> per raggiungere la nuova posizione. <br>
    La relazione che esiste tra <b>WasteService</b> e <b>Transport trolley</b> è quindi di tipo "use". <br>
    Questa separazione in due layer rende il sistema più resistente ad eventuali future variazioni della tecnologia utilizzata per il robot (movimento a step con coordinate o meno, tipologia di hardware del robot). 
    Il <b>WasteService</b> continuerà ad inviare al <b>Transport trolley</b> gli stessi comandi astratti, senza preoccuparsi di "in che modo" o "con quali mezzi" la destinazione viene raggiunta.

    <h4>Dove collocare <b>Transport trolley</b>:</h4>
    Risulta concettualmente sensato porre <b>Transport trolley</b> nello stesso contesto di <i>basicrobot</i>.<br>
    <b>Transport trolley</b> potrebbe infatti necessitare di cambiamenti nel caso in cui cambi il <b>DDR Robot</b> e la tecnologia di movimento usata. <br>
    Si noti tuttavia che, qualora tale componente debba fare utilizzo di un planner (che effettua una ricerca nello spazio degli stati), allora si dovrebbe considerare la possibilità 
    di porre tale attore su un nodo computazionale più potente, dove il consumo di potenza non è un problema (mentre si presume che il robot sia alimentato a batteria). <br>
    Alla luce delle osservazioni sinora fatte, l'architettura logica attuale è la seguente:
    <img class="centerimg" style="width: 500px;" src="docs/_images/logic_architecure_1.png"/>
    <p style="width: 100%; text-align: right;"><a href="../docs_common/Legenda.html">Legenda</a></p>

    <h4><b>Transport trolley</b> non gestisce autonomamente carico/scarico:</h4>
    <p>Per questioni di flessibilità, abbiamo tenuto separate le operazioni di carico, scarico e movimento. In questo modo se dovesse cambiare il processo di smistamento basterà modificare la 
        sequenza di comandi che vengono impartiti al <b>Transport trolley</b>, senza bisogno di modificare quest'ultimo. Riteniamo inoltre corretto far gestire questa 
        operazione a <b>Transport trolley</b>, siccome un domani potrebbe esser necessario inviare comandi o segnali a HW presente sul robot per compiere queste azioni.</p>
    <code><pre>
//RESULT =  OK | ERROR
Request pickup         : pickup(_)
Reply   pickupanswer   : pickupanswer(RESULT)
Request dropout        : dropout(_)
Reply   dropoutanswer  : dropoutanswer(RESULT)</pre>
    </code>

    <h4>Interazioni con il <b>Transport trolley</b>:</h4>
    <p>Si noti come le interazioni con il <b>Transport trolley</b> siano tutte delle request-response. <br>
        Colui che comanda il <b>Transport trolley</b> (cioè una visione astratta e ad alto livello del robot) si aspetta una interazione sincrona bloccante, e si aspetta una risposta con l'esito dell'operazione.<br>
        Tuttavia, solo per il comando <i>move(POSITION)</i>, è possibile comandare una nuova destinazione anche se quella precedente non è stata ancora raggiunta. <br>
        Questo perchè è possibile che arrivi un nuovo <b>Waste-truck</b> mentre il <b>Transport trolley</b> sta tornando a <b>HOME</b>. In questo modo è possibile soddisfare il requisito di gesione immediata della nuova richiesta senza aspettare che il <b>Transport trolley</b> raggiunga <b>HOME</b>. 
        Il nuovo comando annulla di fatto la <i>move</i> precedente, quindi si riceverà solo la risposta relativa all'ultimo comando.
    </p>


    <br>
    <br>
    <br>
    <br>
    <br>
    <br>


    <h3>Principio di funzionamento del <b>Transport trolley</b>: 
        <br> Sistema a coordinate, o semplice macchina a stati che rileva impatto con i muri?</h3>
    <p>La particolare collocazione delle zone <b>INDOOR</b>, <b>PLASTICBOX</b>, <b>GLASSBOX</b>, <b>HOME</b> rende attuabile una soluzione che non richiede l'utilizzo di coordinate: il robot può infatti muoversi all'interno della <b>Service area</b> lungo le pareti, orientandosi semplicemente rilevando le collisioni con le pareti. <br>
        In questa sezione analizziamo i punti a favore dell'utilizzo un sistema a coordinate e uno senza coordinate:</p>
    <p>I vantaggi nell'utilizzo di un sistema a coordinate:</p>
    <ul>
        <li>Potenziale riuso di moduli che già abbiamo sviluppato (mapper, planner)</li>
        <li>Maggiore flessibilità (posizione dei siti non è più negli angoli, robot deve seguire un percorso ottimo, ostacoli nel percorso, gestione più semplice del cambio di destinazione mentre il robot è in movimento)</li>
    </ul>
    <p>I vantaggi nell'utilizzo di un sistema senza coordinate:</p>
    <ul>
        <li>Minor complessità, minor costo</li>
        <li>Maggior velocità negli spostamenti, e maggior velocità di reazione a comandi di halt</li>
        <li>Possibile miglior reazione (piuttosto che a singoli step) da parte di robot reali che non fatto uso di sistemi in feedback o altro hardware per controllare meglio la propria posizione</li>
    </ul>
    <br>
    <p>Per la realizzazione del <b>Transport trolley</b> sono state analizzate 3 diverse opzioni, che vengono qui descritte: </p>

    <h4>OPZIONE 1</h4>
    <p>Si tratta di una semplice macchina a stati che è in grado di raggiungere la destinazione facendo fare al robot sempre un giro in senso antiorario. <br>
        Se viene cambiata la destinazione mentre il robot è in movimento, esso non cambia direzione, perchè comunque per raggiugere ogni altro sito procede in senso antiorario, e quindi il prossimo sito deve comunque essere raggiunto.
    </p>
    <img class="centerimg" style="width: 400px;" src="docs/_images/transporttrolley_option1_explaination.png"/>
    <p>Pro e Contro:</p>
    <ul>
        <li>+ semplicità</li>
        <li>+ possibile estendere la soluzione appena mostrata per attenere l'opzione successiva</li>
        <li>- poca flessibilità</li>
        <li>- politica non molto efficiente</li>
    </ul>
    <p>La macchina a stati che deve essere implementata all'interno di <b>Transport trolley</b> se si vuole percorrere questa soluzione è la seguente:</p>
    <img class="centerimg" src="docs/_images/transporttrolley_option1_verbose_state_machine.png"/>
    <p>Tuttavia è possibile implementarla in maniera più sintetica e compatta nel seguente modo:</p>
    <img class="centerimg" style="width: 500px;" src="docs/_images/transporttrolley_option1_compact_state_machine.png"/>
    
    <h4>OPZIONE 2</h4>
    <p>Si tratta di un'estensione dell'opzione 1: il robot è in grado di raggiungere la prossiama destinazione procedendo sia in senso orario che in senso antiorario (in base a cosa è più conveniente in quel momento). 
        Inoltre il robot può cambiare rotta anche mentre si sta muovendo in avanti. </p>
    <img class="centerimg" style="width: 400px;" src="docs/_images/transporttrolley_option2_explaination.png"/>
    <p>Pro e Contro:</p>
    <ul>
        <li>+ più veloce in alcuni casi</li>
        <li>- più complesso</li>
    </ul>
    <p>La macchina a stati che deve essere implementata all'interno di <b>Transport trolley</b> si complica, perchè tra ogni "macro stato" e l'altro il ramo ha molti più stati:</p>
    <img class="centerimg" src="docs/_images/transporttrolley_option2_verbose_state_machine.png"/>
    <p>E' pur sempre possibile una implementazione più sintetica e compatta:</p>
    <img class="centerimg" style="max-width: 1100px;" src="docs/_images/transporttrolley_option2_compact_state_machine.png"/>

    <hr>

    <h4>OPZIONE 3</h4>
    <p>Il modulo, data la posizione corrente e l'orientamento del robot, fa un certo numero di step per raggiungere le coordinate di destinazione.</p>
    <img class="centerimg" style="width: 400px;" src="docs/_images/transporttrolley_option3_explaination.png"/>
    <p>Pro e Contro:</p>
    <ul>
        <li>+ flessibilità</li>
        <li>+ esiste sw per mappare le dimensioni della stanza (<a href="https://github.com/anatali/issLab2022/tree/main/unibo.mapperQak22">unibo.mapperQak22</a>) e per trovare path (<a href="https://github.com/anatali/issLab2022/tree/main/unibo.planner22">unibo.planner22</a>)</li>
        <li>- rischiesto mapping iniziale della servicearea</li>
        <li>- le dimensioni della servicearea potrebbero non essere multiple di RD. È dunque necessaria una logica che (una volta raggiunte le coordinate di destinazione) faccia andare il robot a contatto con la porta, per poter effettuare le operazioni di carico/scarico.</li>
    </ul>
         
    <h4>Scelta: OPZIONE 1</h4>
    <p>Scegliamo la prima soluzione perché è la più semplice e quindi economica, fermo restando che a partire da questa è possibile estenderla per ottenere la seconda versione.<br>
        Inoltre se un giorno nuovi requisiti dovessero imporre l'utilizzo di un sistema di coordinate, verrebbe modificato soltanto il componente "transporttrolley".</p>
    <hr>

    <h3><b>WasteService</b></h3>
    <p>Possiamo pensare il <b>WasteService</b> come il componente controller, ossia quello che contiene la business logic del sistema.<br>
        Abbiamo analizzato le funzionalità che il servizio <b>WasteService</b> deve offrire, e abbiamo quindi formalizzato tale entità con il modello qak. <br>
        Per una migliore comprensione il diagramma degli stati di questo attore viene qui riassunto con il seguente schema: </p>
    <img class="centerimg" src="docs/_images/wasteservice_actor_state_diagram_1.png"/>
    
    

</div>
    


<!--<h2>Project</h2> 
</div>-->


<h2>Test plans</h2> 
<div class="remark">
    Per il <b>Test plan</b> sono state definite due classi JUnit <b><a href="QakSprint1/test/testSprint1/TestSprint1_simple.kt">TestSprint1_simple</a></b> e <b><a href="QakSprint1/test/testSprint1/TestSprint1_hystory.kt">TestSprint1_hystory</a></b><br>
    Sono stati resi osservabili tramite Coap gli attori WasteService e TrasportTrolley.<br>
    <p>Sono state inoltre create due classi di utilità <b><a href="QakSprint1/test/testSprint1/TestObserver.java">TestObserver</a></b> e <b><a href="QakSprint1/test/testSprint1/TestUtils.kt">TestUtils</a></b>  in grado di leggere lo storico delle informazioni di WasteService e TrasportTrolley
    e poterne valutare il corretto funzionamento nei test<br></p>

    <h4><p>Test effettuati:</p></h4>
    <ul>
        <h5>TestSprint1_simple.kt:</h5>
        <li><b>test_2_accepted()</b>: Test due richieste accettate</li>
        <li><b>test_1_accepted_1_rejected()</b>: Test due richieste una accettata e una rifiutata</li>
        <h5>Classe di test TestSprint1_hystory.kt:</h5>
        <p>La seguente classe di test verifica inoltre i cambiamenti di stato che avvengono negli attori <b>WasteService</b> e <b>TrasportTrolley</b> mediante un <u>Observer CoAP</u>.</p><br>
        <lI><b>test_accepted()</b>: Test singola richiesta accettata</lI>
        <li><b>test_rejected()</b>: Test singola richiesta rifiutata</li>
        <li><b>test_2_accepted_while_in_operation()</b>: Test due richieste (la seconda inviata mentre la prima richiesta non era ancora conclusa) accettate</li>
        <li><b>test_1_accepted_1_rejected_while_in_operation()</b>: Test due richieste (la seconda inviata mentre la prima richiesta non era ancora conclusa) una accettata e una rifiutata</li>
        <li><b>test_2_accepted_while_returning_home()</b>: Test due richieste (la seconda inviata mentre il robot stava tornando a casa dalla prima richiesta) accettate</li>
        <li><b>test_1_accepted_1_rejected_while_returning_home</b>: Test due richieste (la seconda inviata mentre il robot stava tornando a casa dalla prima richiesta) una accettata e una rifiutata</li>
        <li><b>test_1_accepted_1_rejected_while_returning_home_1_accepted()</b>: Test dove se si riceva una depositrequest, ed essa è poi rifiutata, viene consumato il messaggio mediante un autoanello nello stato di wait</li>
    
    </ul>

</div>

<h3><a href="QakSprint1/src/Prototype/demo0.qak">Metamodello eseguibile QAK</a></h3>
 
<!-- USEFUL
<table style="width:100%" border="1">
<tr>
<td style="width:50%">
</td>
<td></td>
</tr>
</table>
-->
	      	
<br/><br/> 	
</div>  

<div style="background-color:rgba(86, 56, 253, 0.9); width:100%;text-align:left;color:white">
    <table style="border: 0px solid transparent; margin: 0 auto;">
        <tr>
            <td>
                <p style="font-weight: bold;">Loris Giannatempo <br>
                Email: loris.giannatempo@studio.unibo.it</p>
                <img class="centerimg" src="../docs_common/lorisgiannatempo.jpg" style="width: 30%; height: 30%; border: 0px">
            </td>
            <td>
                <p style="font-weight: bold;">Davide Guidetti <br>
                Email: davide.guidetti3@studio.unibo.it</p>
                <img class="centerimg" src="../docs_common/davideguidetti.jpg" style="width: 30%; height: 30%; border: 0px">
            </td>
        </tr>
    </table>
</div> 
</body>
</html>