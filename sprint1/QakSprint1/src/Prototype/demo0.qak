//https://dl.bintray.com/jetbrains/kotlin/eclipse-plugin/0.8.19/
  
System demo0    
//mqttBroker "localhost" : 1883 eventTopic "demo0/events"
//mqttBroker "broker.hivemq.com" : 1883 eventTopic "demo0/events"
  
// ------------ wasteservice msgs --------------------
//MATERIAL = PLASTIC | GLASS
//TRUCKLOAD =  float number
Request depositrequest : depositrequest(MATERIAL, TRUCKLOAD)
Reply loadaccept       : loadaccept(MATERIAL, TRUCKLOAD)
Reply loadrejected     : loadrejected(MATERIAL, TRUCKLOAD)
// ------------------------------------------------------
   
// ------------ transporttrolley msgs -------------------
//RESULT =  OK | ERROR 
Request pickup         : pickup(_)
Reply   pickupanswer   : pickupanswer(RESULT)
Request dropout        : dropout(_)
Reply   dropoutanswer  : dropoutanswer(RESULT)
Request move           : move(POSITION)    //POSITION = INDOOR | PLASTICBOX | GLASSBOX | HOME
Reply   moveanswer     : moveanswer(RESULT)
// ------------------------------------------------------

// -------------------- mover msgs ----------------------
//   (same as transporttrolley)
//Request move           : move(POSITION)    //POSITION = INDOOR | PLASTICBOX | GLASSBOX | HOME
//Reply   moveanswer     : moveanswer(RESULT)
// ------------------------------------------------------

// --------------- depositaction msgs -------------------
Request depositaction  : depositaction(MATERIAL) 
Reply   pickupdone	   : pickupdone(_)
Dispatch err		   : err(_)
// ------------------------------------------------------

// ---------------- moveruturn messages -----------------
Request moveruturn     : moveruturn(CURRDIR)  //CURRDIR = ACLK | CLK
Reply moveruturnanswer : moveruturnanswer(RESULT) //RESULT =  OK | ERROR 
// ------------------------------------------------------

// --------------- basicrobotwrapper msgs ---------------
//RESULT =  OK | ERROR 
//MOVE =  w | l | r | h     //the command end when the reply is sent
Request cmdsync   	: cmdsync(MOVE)
Reply cmdanswer   	: cmdanswer(RESULT)
// ------------------------------------------------------

// ------------------ basicrobot msgs -------------------
//MOVE =  w | a | s | d | h    | l | r   //w and s: the robot continues to go until an obstacle is found
Dispatch cmd       	: cmd(MOVE)
Dispatch end       	: end(ARG)
 
Request step       : step( TIME )	
Reply   stepdone   : stepdone(V)  
Reply   stepfail   : stepfail(DURATION, CAUSE)
 
 
Event 	 moving        : moving (F,T)
Event    info          : info( ARG ) 	    //for external components, not coap-observed
Event    sonar         : sonar(DISTANCE,NAME)			//emitted by distancefilter
Dispatch obstacle      : obstacle( ARG ) 	//generated by distancefilter
// ------------------------------------------------------

//method to trigger the next transition within the state: send this message to the actor itself (cumbersome but works great)
Dispatch noMsg : noMsg(_)




// ------------------ CONTEXTS -------------------
//REMEMBER TO PUT datacleaner AND distancefilter IN THE SAME CONTEXT OF basicrobot
Context ctxserver ip [host="localhost" port=8095]
Context ctxrobot ip  [host="127.0.0.1" port=8096]
// ------------------------------------------------

// ------- basicrobot collision detection ---------
CodedQActor distancefilter context ctxrobot className "rx.distanceFilter"   //Nel caso di robot virtuale semplicemente assorbe eventi obstacle e reinvia dispatch "obstacle:obstacle(virtual)" a basicrobot. Nel caso di robot reali riceve messaggi "sonarRobot" e invia a basicrobot dispatch "obstacle:obstacle(dist)" se vicino, altrimenti sonardata", "sonardata:distance(dist)" se lontano.
// ------------------------------------------------


QActor wasteservice context ctxserver{
	[# lateinit var Material  : ws.Material
	   var TruckLoad : Float = 0F

	   lateinit var RES : String
	   lateinit var TrolleyPos : String   //gbox,pbox,Home,indoor
	#]
	
	State wait initial {
			printCurrentMessage
			updateResource [# "wasteservice(wait,${ws.func.contPB},${ws.func.contGB})" #]
			discardMsg Off
	}
	Transition t0 whenRequest depositrequest -> handle_req
				  whenMsg   err -> error
	
	State handle_req{
		updateResource [# "wasteservice(handle_req,${ws.func.contPB},${ws.func.contGB})" #] 
		printCurrentMessage
		onMsg(depositrequest : depositrequest(MATERIAL, TRUCKLOAD)) {
			[#
				 Material 	= ws.Material.valueOf(payloadArg(0))
				 TruckLoad 	= payloadArg(1).toFloat()
			#]
			println("wasteservice | arrived $TruckLoad Kg of $Material")
			if[# ws.func.checkdepositpossible( Material, TruckLoad ) #]{
				[# ws.func.updateDeposit( Material, TruckLoad ) 
					#]
				println("wasteservice | PB capacity: ${ws.func.contPB}, GB capacity: ${ws.func.contGB}")	
				[# RES="OK"#]
			} else{  
				[# RES="ERR" #]
			}		
		} 
	}
	Goto req_depositaction if [# RES=="OK" #] else rejected
	
	State rejected{
		println("wasteservice | rejected")
		updateResource [# "wasteservice(rejected,${ws.func.contPB},${ws.func.contGB})" #]
		printCurrentMessage
 		replyTo depositrequest with loadrejected : loadrejected($Material,$TruckLoad)
	}
	Goto wait
	
	State req_depositaction{
		println("wasteservice | req_depositaction")
		updateResource [# "wasteservice(req_depositaction,${ws.func.contPB},${ws.func.contGB})" #]
		printCurrentMessage
		request depositaction -m depositaction : depositaction($Material)
	}
	Transition t0 whenReply pickupdone -> chk_depositaction
				  whenMsg   err -> error
	
	State chk_depositaction{
		printCurrentMessage
		updateResource [# "wasteservice(chk_depositaction,${ws.func.contPB},${ws.func.contGB})" #]
		replyTo depositrequest with loadaccept : loadaccept($Material,$TruckLoad)	
	}
	Goto wait
	
	
 	State error {
 		updateResource [# "wasteservice(error,${ws.func.contPB},${ws.func.contGB})" #] 
 		println("wasteservice | error")
 		printCurrentMessage
 	}
}

QActor depositaction context ctxserver{
	[# lateinit var RES : String
	   lateinit var MATERIAL : ws.Material #]
	
	State error {
		updateResource [# "depositaction(error)" #] 
 		println("depositaction | error")
 		printCurrentMessage
 		forward wasteservice -m err : err(_)
	}
	
	State wait initial{
		updateResource [# "depositaction(wait)" #] 
		printCurrentMessage
		discardMsg Off
	}
	Transition t0 whenRequest depositaction -> req_move_indoor
	
	State req_move_indoor {
		printCurrentMessage
		onMsg(depositaction : depositaction(MATERIAL)){
			[# MATERIAL=ws.Material.valueOf(payloadArg(0)) #]
			request transporttrolley -m move : move(INDOOR)
		}
		updateResource [# "depositaction(req_move_indoor,$MATERIAL)" #] 
	}
	Transition t0 whenReply moveanswer -> chk_move_indoor
	State chk_move_indoor {
		updateResource [# "depositaction(chk_move_indoor,$MATERIAL)" #] 
		printCurrentMessage
		onMsg(moveanswer : moveanswer(RES)){
			[# RES = payloadArg(0); #]
		}
	}
	Goto req_pickup if [# RES=="OK" #] else error
	
	State req_pickup{
		printCurrentMessage
		updateResource [# "depositaction(req_pickup,$MATERIAL)" #] 
		request transporttrolley -m pickup : pickup(_)
	}
	Transition t0 whenReply pickupanswer -> chk_pickup
	State chk_pickup{
		printCurrentMessage
		updateResource [# "depositaction(chk_pickup,$MATERIAL)" #] 
		onMsg(pickupanswer : pickupanswer(RES)){
			[# RES = payloadArg(0); #]
		}
	}
	Goto reply if [# RES=="OK" #] else error
	
	State reply {
		printCurrentMessage
		updateResource [# "depositaction(reply,$MATERIAL)" #] 
		replyTo depositaction with pickupdone: pickupdone(_)
	}
	Goto req_move_container
	
	State req_move_container {
		[# 
			val Position = when(MATERIAL){
			    ws.Material.PLASTIC -> ws.Position.PLASTICBOX
			    ws.Material.GLASS -> ws.Position.GLASSBOX
			} #]
		printCurrentMessage
		updateResource [# "depositaction(req_move_container,$MATERIAL)" #] 
		request transporttrolley -m move : move($Position)
	}
	Transition t0 whenReply moveanswer -> chk_move_container
	State chk_move_container{
		printCurrentMessage
		updateResource [# "depositaction(chk_pickup,$MATERIAL)" #] 
		onMsg(moveanswer : moveanswer(RES)){
			[# RES = payloadArg(0); #]
		}
	}
	Goto req_dropout if [# RES=="OK" #] else error
	
	State req_dropout{
		updateResource [# "depositaction(req_dropout,$MATERIAL)" #] 
		request transporttrolley -m dropout : dropout(_)
	}
	Transition t0 whenReply dropoutanswer -> chk_dropout
	State chk_dropout{
		printCurrentMessage
		updateResource [# "depositaction(chk_dropout,$MATERIAL)" #] 
		onMsg(dropoutanswer : dropoutanswer(RES)){
			[# RES = payloadArg(0); #]
		}
	}
	Goto next_move if [# RES=="OK" #] else error

	State next_move{
		printCurrentMessage
		updateResource [# "depositaction(next_move,$MATERIAL)" #] 
	}
	Transition t0 whenTime 10 -> move_home
				  whenRequest depositaction -> req_move_indoor
	
	State move_home{
		printCurrentMessage
		updateResource [# "depositaction(move_home,$MATERIAL)" #] 
		request transporttrolley -m move : move(HOME)
	}
	Transition t0 whenRequest depositaction -> req_move_indoor
				  whenReply   moveanswer -> wait
}



QActor transporttrolley context ctxrobot{
	[# val actor = this@Transporttrolley;
		suspend fun transitNow(stateName : String){
			var res = actor.handleCurrentMessage(NoMsg,actor.getStateByName(stateName));
			if(res) actor.elabMsgInState( );
			else println("ERROR: transition was not possible")
		}
		lateinit var RES : String
	#]
	
 	State wait initial {
 		printCurrentMessage
 		updateResource [# "transporttrolley(wait)" #]
 	}
 	Transition toNewState whenRequest pickup -> req_pickup
 						  whenRequest dropout -> req_dropout
 						  whenRequest move -> req_move
 						  
 	State req_pickup {
 		printCurrentMessage
 		updateResource [# "transporttrolley(req_pickup)" #]
 		request pickupdropouthandler -m pickup : pickup(_)
 	}
 	Transition toNewState whenReply pickupanswer -> chk_pickup
 	State chk_pickup {
 		printCurrentMessage
 		updateResource [# "transporttrolley(chk_pickup)" #]
 		onMsg( pickupanswer:pickupanswer(RES) ){
 			[# RES = payloadArg(0)#]
 			if[# RES=="OK" #]{
 				replyTo pickup with pickupanswer : pickupanswer(OK)
 			}else{
 				replyTo pickup with pickupanswer : pickupanswer(ERROR)
 			}
 		}
 	}
 	Goto wait
 	
 	State req_dropout {
 		printCurrentMessage
 		updateResource [# "transporttrolley(req_dropout)" #]
 		request pickupdropouthandler -m dropout : dropout(_)
 	}
 	Transition toNewState whenReply dropoutanswer -> chk_dropout
 	State chk_dropout {
 		printCurrentMessage
 		updateResource [# "transporttrolley(chk_dropout)" #] 
 		onMsg( dropoutanswer:dropoutanswer(RES) ){
 			[# RES = payloadArg(0)#]
 			if[# RES=="OK" #]{
 				replyTo dropout with dropoutanswer : dropoutanswer(OK)
 			}else{
 				replyTo dropout with dropoutanswer : dropoutanswer(ERROR)
 			}
 		}
 	}
 	Goto wait
 	
 	State req_move {
 		printCurrentMessage
 		[# var Pos : ws.Position? = null #]
 		onMsg( move:move(POS) ){
			[# Pos=ws.Position.valueOf(payloadArg(0)) #]
 			//println("transporttrolley | New robot destination: ${pos}")
 			request mover -m move : move($Pos)
 		}
 		updateResource [# "transporttrolley(req_move,$Pos)" #] 
 	}
 	Transition toNewState whenReply moveanswer -> chk_move
 							whenRequest move -> req_move //cancel current destination and set the new one
 	State chk_move {
 		printCurrentMessage
 		updateResource [# "transporttrolley(chk_move)" #] 
 		onMsg( moveanswer:moveanswer(RES) ){
 			[# RES = payloadArg(0)#]
 			if[# RES=="OK" #]{
 				replyTo move with moveanswer : moveanswer(OK)
 			}else{
 				replyTo move with moveanswer : moveanswer(ERROR)
 			}
 		}
 	}
 	Goto wait
}


QActor pickupdropouthandler context ctxrobot{
	 
	State wait initial {
		discardMsg Off
	 	printCurrentMessage
		updateResource [# "pickupdropouthandler(wait)" #] 
	}
	Transition t0 whenRequest dropout -> do_dropout
					whenRequest pickup -> do_pickup
	
	State do_dropout {
	 	printCurrentMessage
		updateResource [# "pickupdropouthandler(do_dropout)" #]
		println("pickupdropouthandler | DROPOUT STARTING...")
		delay 1000 //simulate operation
		println("pickupdropouthandler | DROPOUT COMPLETE")
		replyTo dropout with dropoutanswer:dropoutanswer(OK)
	}
	Goto wait
	
	State do_pickup {
		printCurrentMessage
		updateResource [# "pickupdropouthandler(do_pickup)" #]
		println("pickupdropouthandler | PICKUP STARTING...")
		delay 1000 //simulate operation
		println("pickupdropouthandler | PICKUP COMPLETE")
		replyTo pickup with pickupanswer:pickupanswer(OK)
	}
	Goto wait
	
}

//RECEIVES move(POS) MESSAGES, MOVES THE ROBOT INTO POS, AND REPLY WITH moveanswer(RES)
//basically it translates high level move to the final position, into low level robot moves
QActor mover context ctxrobot{
	[# var DEST = ws.Position.HOME
	   var CURRPOS = ws.Position.HOME
	   var CURRDIR = "ACLK" // ACLK | CLK
	   lateinit var RES : String
	#]
	
	State wait initial {
		discardMsg Off
		printCurrentMessage
		updateResource [# "mover(wait,$CURRPOS,$DEST,$CURRDIR)" #]
	}
	Transition t0 whenRequest move -> handle
	
	State handle {
		printCurrentMessage
		onMsg( move:move(POS) ){
			[# DEST = ws.Position.valueOf(payloadArg(0))#]
			if [# DEST==CURRPOS#] {
				replyTo move with moveanswer : moveanswer(OK)
			}
		}
		updateResource [# "mover(handle,$CURRPOS,$DEST,$CURRDIR)" #]
	}
	Goto aclk_or_clk if [# DEST!=CURRPOS #] else wait //if the destination is different form the current position, reach next corner
	
	State aclk_or_clk {
		printCurrentMessage
		updateResource [# "mover(aclk_or_clk,$CURRPOS,$DEST,$CURRDIR)" #]
	}
	Goto prepare_aclk if [# DEST==ws.func.nextPos(CURRPOS) || DEST==ws.func.nextPos(ws.func.nextPos(CURRPOS)) #] else prepare_clk //decide which direction to take depending on the current position and destination
	
	//------------------------------- REACHING NEXT CORNER IN ANTICLOCKWISE DIRECTION -------------------------------
	State prepare_aclk {
		printCurrentMessage
		updateResource [# "mover(prepare_aclk,$CURRPOS,$DEST,$CURRDIR)" #]
	}
	Goto req_pre_turn_aclk if [# CURRDIR!="ACLK" #] else req_forward_aclk
	
	State req_pre_turn_aclk {
		printCurrentMessage
		updateResource [# "mover(req_pre_turn_aclk,$CURRPOS,$DEST,$CURRDIR)" #]
		request basicrobotwrapper -m cmdsync : cmdsync(r)
	}
	Transition t0 whenReply cmdanswer -> chk_pre_turn_aclk
	State chk_pre_turn_aclk {
		printCurrentMessage
		updateResource [# "mover(chk_pre_turn_aclk,$CURRPOS,$DEST,$CURRDIR)" #]
		onMsg( cmdanswer:cmdanswer(RES) ){
			[# RES = payloadArg(0)#]
		}
	}
	Goto req_forward_aclk if [# RES=="OK" #] else error
	
	State req_forward_aclk {
		printCurrentMessage
		[# CURRDIR="ACLK" #]
		updateResource [# "mover(req_forward_aclk,$CURRPOS,$DEST,$CURRDIR)" #]
		request basicrobotwrapper -m cmdsync : cmdsync(w)
	}
	Transition t0 whenReply cmdanswer -> chk_forward_aclk //wall reached
					whenRequest move -> set_new_dest_aclk //new position arrived
	State chk_forward_aclk {
		printCurrentMessage
		updateResource [# "mover(chk_forward_aclk,$CURRPOS,$DEST,$CURRDIR)" #]
		onMsg( cmdanswer:cmdanswer(RES) ){
			[# RES = payloadArg(0)#]
		}
	}
	Goto req_post_turn_aclk if [# RES=="OK" #] else error
	State set_new_dest_aclk { //set new position and decide if it's convenient to change direction
		printCurrentMessage
		onMsg( move:move(POS) ){
			[# DEST = ws.Position.valueOf(payloadArg(0))#]
		}
		updateResource [# "mover(set_new_dest_aclk,$CURRPOS,$DEST,$CURRDIR)" #]
	}
	Goto req_forward_aclk if [# DEST==ws.func.nextPos(CURRPOS) || DEST==ws.func.nextPos(ws.func.nextPos(CURRPOS)) #] //continue with the current route if the destination is the position we are currently reaching ( nextPos(CURRPOS) ) or the next one ( nextPos(nextPos(CURRPOS)) )
		else req_u_turn //otherwise it's more convenient to return back return back
	
	State req_post_turn_aclk {
		printCurrentMessage
		updateResource [# "mover(req_post_turn_aclk,$CURRPOS,$DEST,$CURRDIR)" #]
		request basicrobotwrapper -m cmdsync : cmdsync(l)
	}
	Transition t0 whenReply cmdanswer -> chk_post_turn_aclk
	State chk_post_turn_aclk {
		printCurrentMessage
		updateResource [# "mover(chk_post_turn_aclk,$CURRPOS,$DEST,$CURRDIR)" #]
		onMsg( cmdanswer:cmdanswer(RES) ){
			[# RES = payloadArg(0)#]
		}
	}
	Goto update_aclk if [# RES=="OK" #] else error
	
	State update_aclk {
		printCurrentMessage
		[# CURRPOS=ws.func.nextPos(CURRPOS) #]
		updateResource [# "mover(update_aclk,$CURRPOS,$DEST,$CURRDIR)" #]
	}
	Goto reply	
	//---------------------------------------------------------------------------------------------------------------
	
	//--------------------------------- REACHING NEXT CORNER IN CLOCKWISE DIRECTION ---------------------------------
	State prepare_clk {
		printCurrentMessage
		updateResource [# "mover(prepare_clk,$CURRPOS,$DEST,$CURRDIR)" #]
	}
	Goto req_pre_turn_clk if [# CURRDIR!="CLK" #] else req_forward_clk
	
	State req_pre_turn_clk {
		printCurrentMessage
		updateResource [# "mover(req_pre_turn_clk,$CURRPOS,$DEST,$CURRDIR)" #]
		request basicrobotwrapper -m cmdsync : cmdsync(l)
	}
	Transition t0 whenReply cmdanswer -> chk_pre_turn_clk
	State chk_pre_turn_clk {
		printCurrentMessage
		updateResource [# "mover(chk_pre_turn_clk,$CURRPOS,$DEST,$CURRDIR)" #]
		onMsg( cmdanswer:cmdanswer(RES) ){
			[# RES = payloadArg(0)#]
		}
	}
	Goto req_forward_clk if [# RES=="OK" #] else error
	
	State req_forward_clk {
		printCurrentMessage
		[# CURRDIR="CLK" #]
		updateResource [# "mover(req_forward_clk,$CURRPOS,$DEST,$CURRDIR)" #]
		request basicrobotwrapper -m cmdsync : cmdsync(w)
	}
	Transition t0 whenReply cmdanswer -> chk_forward_clk //wall reached
					whenRequest move -> set_new_dest_clk //new position arrived
	State chk_forward_clk {
		printCurrentMessage
		updateResource [# "mover(chk_forward_clk,$CURRPOS,$DEST,$CURRDIR)" #]
		onMsg( cmdanswer:cmdanswer(RES) ){
			[# RES = payloadArg(0)#]
		}
	}
	Goto req_post_turn_clk if [# RES=="OK" #] else error
	State set_new_dest_clk { //set new position and decide if it's convenient to change direction
		printCurrentMessage
		onMsg( move:move(POS) ){
			[# DEST = ws.Position.valueOf(payloadArg(0))#]
		}
		updateResource [# "mover(set_new_dest_clk,$CURRPOS,$DEST,$CURRDIR)" #]
	}
	Goto req_forward_clk if [# DEST==ws.func.prevPos(CURRPOS) || DEST==ws.func.prevPos(ws.func.prevPos(CURRPOS)) #] //continue with the current route if the destination is the position we are currently reaching ( nextPos(CURRPOS) ) or the next one ( nextPos(nextPos(CURRPOS)) )
		else req_u_turn //otherwise it's more convenient to return back return back
	
	State req_post_turn_clk {
		printCurrentMessage
		updateResource [# "mover(req_post_turn_clk,$CURRPOS,$DEST,$CURRDIR)" #]
		request basicrobotwrapper -m cmdsync : cmdsync(r)
	}
	Transition t0 whenReply cmdanswer -> chk_post_turn_clk
	State chk_post_turn_clk {
		printCurrentMessage
		updateResource [# "mover(chk_post_turn_clk,$CURRPOS,$DEST,$CURRDIR)" #]
		onMsg( cmdanswer:cmdanswer(RES) ){
			[# RES = payloadArg(0)#]
		}
	}
	Goto update_clk if [# RES=="OK" #] else error
	
	State update_clk {
		printCurrentMessage
		[# CURRPOS=ws.func.prevPos(CURRPOS) #]
		updateResource [# "mover(update_clk,$CURRPOS,$DEST,$CURRDIR)" #]
	}
	Goto reply
	//---------------------------------------------------------------------------------------------------------------
	
	//-------------------------------------- U TURN ------------------------------------------
	State req_u_turn {
		printCurrentMessage
		request moveruturn -m moveruturn : moveruturn($CURRDIR)
		updateResource [# "mover(req_u_turn,$CURRPOS,$DEST,$CURRDIR)" #]
	}
	Transition t0 whenReply moveruturnanswer -> chk_u_turn
					whenReply moveanswer -> req_u_turn //consume possible incoming moveanswer due to critical race condition (new position for witch u turn is needed arrived, but the robot reaches the wall: the basicrobotwrapper replies before receiving the new commands from moveruturn)
	State chk_u_turn {
		printCurrentMessage
		onMsg( moveruturnanswer:moveruturnanswer(RES) ){
			[# RES = payloadArg(0)#]
		}
		[# CURRDIR = when(CURRDIR){
				"ACLK" -> "CLK"
				"CLK"  -> "ACLK"
				else -> {println("moveruturn | error: unknow direction $CURRDIR"); ""}
		   } #]
		updateResource [# "mover(chk_u_turn,$CURRPOS,$DEST,$CURRDIR)" #]
	}
	Goto reply if [# RES=="OK" #] else error
	//-----------------------------------------------------------------------------------------
	
	State reply {
		printCurrentMessage
		if[# CURRPOS==DEST #]{
			replyTo move with moveanswer : moveanswer(OK)
		}
		updateResource [# "mover(reply,$CURRPOS,$DEST,$CURRDIR)" #]
	}
	Transition t0 whenTime 10 -> handle //no messages, go to handle
					whenRequest move -> handle //new destination, consume the message while going to handle
	
	State error{
		printCurrentMessage
		updateResource [# "mover(error,$CURRPOS,$DEST,$CURRDIR)" #]
		replyTo move with moveanswer : moveanswer(ERROR)
		println("mover | ERROR STATE")
	}
}

QActor moveruturn context ctxrobot{
	[#  lateinit var RES : String
		var ENDDIR : String? = null #]
	
	State wait initial {
		discardMsg On
		printCurrentMessage
		updateResource [# "moveruturn(wait,$ENDDIR)" #]
	}
	Transition t0 whenRequest moveruturn -> req_halt
	
	State req_halt {
		printCurrentMessage
		onMsg( moveruturn:moveruturn(DIR) ){
			[# ENDDIR = when(payloadArg(0)){
				"ACLK" -> "CLK"
				"CLK"  -> "ACLK"
				else -> {println("moveruturn | error: unknow direction"); ""}
			   } #]
		}
		updateResource [# "moveruturn(req_halt,$ENDDIR)" #]
		request basicrobotwrapper -m cmdsync : cmdsync(h)
	}
	Transition t0 whenReply cmdanswer -> chk_halt
	State chk_halt {
		printCurrentMessage
		updateResource [# "moveruturn(chk_halt,$ENDDIR)" #]
		onMsg( cmdanswer:cmdanswer(RES) ){
			[# RES = payloadArg(0)#]
		}
	}
	Goto req_turn_1 if [# RES=="OK" #] else error
	
	State req_turn_1 {
		printCurrentMessage
		updateResource [# "moveruturn(req_turn_1,$ENDDIR)" #]
		request basicrobotwrapper -m cmdsync : cmdsync(l)
	}
	Transition t0 whenReply cmdanswer -> chk_turn_1
	State chk_turn_1 {
		printCurrentMessage
		updateResource [# "moveruturn(chk_turn_1,$ENDDIR)" #]
		onMsg( cmdanswer:cmdanswer(RES) ){
			[# RES = payloadArg(0)#]
		}
	}
	Goto req_turn_2 if [# RES=="OK" #] else error
	
	State req_turn_2 {
		printCurrentMessage
		updateResource [# "moveruturn(req_turn_2,$ENDDIR)" #]
		request basicrobotwrapper -m cmdsync : cmdsync(l)
	}
	Transition t0 whenReply cmdanswer -> chk_turn_2
	State chk_turn_2 {
		printCurrentMessage
		updateResource [# "moveruturn(chk_turn_2,$ENDDIR)" #]
		onMsg( cmdanswer:cmdanswer(RES) ){
			[# RES = payloadArg(0)#]
		}
	}
	Goto req_forward if [# RES=="OK" #] else error
	
	State req_forward {
		printCurrentMessage
		updateResource [# "moveruturn(req_forward,$ENDDIR)" #]
		request basicrobotwrapper -m cmdsync : cmdsync(w)
	}
	Transition t0 whenReply cmdanswer -> chk_forward
	State chk_forward {
		printCurrentMessage
		updateResource [# "moveruturn(chk_forward,$ENDDIR)" #]
		onMsg( cmdanswer:cmdanswer(RES) ){
			[# RES = payloadArg(0)#]
		}
	}
	Goto req_final_turn if [# RES=="OK" #] else error
	
	State req_final_turn {
		printCurrentMessage
		updateResource [# "moveruturn(req_final_turn,$ENDDIR)" #]
		if [# ENDDIR == "ACLK" #] {
			request basicrobotwrapper -m cmdsync : cmdsync(l)
		}else{ //ENDDIR = "CLK"
			request basicrobotwrapper -m cmdsync : cmdsync(r)
		}
	}
	Transition t0 whenReply cmdanswer -> chk_final_turn
	State chk_final_turn {
		printCurrentMessage
		updateResource [# "moveruturn(chk_final_turn,$ENDDIR)" #]
		onMsg( cmdanswer:cmdanswer(RES) ){
			[# RES = payloadArg(0)#]
		}
	}
	Goto reply if [# RES=="OK" #] else error
	
	State reply {
		printCurrentMessage
		replyTo moveruturn with moveruturnanswer : moveruturnanswer(OK)
		updateResource [# "moveruturn(reply,$ENDDIR)" #]
	}
	Goto wait
	
	State error{
		printCurrentMessage
		updateResource [# "moveruturn(error,$ENDDIR)" #]
		replyTo move with moveruturnanswer : moveruturnanswer(ERROR)
		println("moveruturn | ERROR STATE")
	}
}

QActor basicrobotwrapper context ctxrobot{
	[# var MOVE : ws.Move? = null  #]
	 
	State wait initial {
		discardMsg On
	 	printCurrentMessage
		updateResource [# "basicrobotwrapper(wait)" #] 
	}
	Transition t0 whenRequest cmdsync -> handle
					
	State handle {
	 	printCurrentMessage
	 	onMsg( cmdsync:cmdsync(MOVE) ){
			[# MOVE = ws.Move.valueOf(payloadArg(0)) #]
		}
		updateResource [# "basicrobotwrapper(handle,$MOVE)" #]
	}
	Goto forward_cmd if [# MOVE==ws.Move.w #] else other_cmd
	
	State other_cmd {
		printCurrentMessage
		updateResource [# "basicrobotwrapper(other_cmd,$MOVE)" #]
		[# val MoveStr = MOVE.toString()#]
		forward basicrobot -m cmd : cmd($MoveStr)
		if[# MOVE==ws.Move.l || MOVE==ws.Move.r #]{
			delay 500 //wait for turn to complete
		}
		delay 100
		replyTo cmdsync with cmdanswer : cmdanswer(OK)
	}
	Goto wait
	
	State forward_cmd {
		printCurrentMessage
		updateResource [# "basicrobotwrapper(forward_cmd)" #]
		forward basicrobot -m cmd : cmd(w)
	}
	Transition t0 whenEvent info -> collision
					whenRequest cmdsync -> handle
					
	State collision {
		printCurrentMessage
		updateResource [# "basicrobotwrapper(collision)" #]
		replyTo cmdsync with cmdanswer : cmdanswer(OK) 
	}
	Goto wait
	
}

QActor basicrobot context ctxrobot{
[#
  var StepTime      = 0L
  var StartTime     = 0L     
  var Duration      = 0L
  var ExpectingCollision = false
  //var RobotType     = "" 
  var CurrentMove   = "unkknown"
#]  
 	State s0 initial { 	      
 		discardMsg Off  //WE want receive any msg
		println("basicrobot | START")	
 		qrun unibo.robot.robotSupport.create(myself,"basicrobotConfig.json")	
 		//[# RobotType = unibo.robot.robotSupport.robotKind #]
 		/*delay 1000  //give to the realsonar the time to start
        if[# RobotType != "virtual" #]{
        	[# var robotsonar = context!!.hasActor("realsonar")  
        	   if(robotsonar != null) unibo.robot.robotSupport.createSonarPipe(robotsonar) 
        	#] 
  		}//The Virtual robot sonar is created in virtualrobotSupport2021*/
 
  		//run unibo.robot.robotSupport.move( "l" )    //synch
 		//run unibo.robot.robotSupport.move( "r" )	//synch
    		//run unibo.robot.robotSupport.move( "w" )    //asynch 
 		updateResource [# "basicrobot(s0)" #]
 	}
	Goto work

	State work{
		println("basicrobot | waiting .............. ")
	}
	Transition t1   whenMsg     cmd       -> execcmd
					whenRequest step      -> doStep
					whenMsg    obstacle   -> handleObstacle  //in virtualrobot caused by the move w/s
					//whenEvent sonar       -> handleSonar
				  	whenMsg     end       -> endwork

	State execcmd{
		printCurrentMessage
		onMsg( cmd : cmd(MOVE) ){
  			//activate the motors
  			[# val Move = payloadArg(0) #]
  			[# if(Move=="w") ExpectingCollision=true #]
  			println("basicrobot | executing '${Move}'")
			run unibo.robot.robotSupport.move( Move )
			updateResource [# "basicrobot(execcmd,$Move)" #]
		}
	 }
	 Goto work

	State handleObstacle{
		printCurrentMessage
		//println("basicrobot | handleObstacle")
		if[# ExpectingCollision #]{
			[# ExpectingCollision=false #]
			run unibo.robot.robotSupport.move( "h" )
			delay 600
			updateResource [# "basicrobot(handleObstacle,${CurrentMove})" #]
			/*if[# CurrentMove == "w"#]{
			//back to avoid emission of obstacle again if real robot moving forward !!!
			//if[# RobotType != "virtual" #]{	//is it better to embed this behavior in the support?
				run unibo.robot.robotSupport.move( "s" )
				delay 100
				run unibo.robot.robotSupport.move( "h" )
	 		}*/
	 		emit info : info( obstacledoing(w) )
	 		//forward transporttrolley -m wall : wall( obstacledoing(w) )
		}
	}
	Goto work

	/*State handleSonar{
		printCurrentMessage
	}
	Goto work*/

   	State doStep{
 		printCurrentMessage
		onMsg( step : step( T ) ){
			[#	StepTime = payloadArg(0).toLong() 	#]
			updateResource [# "basicrobot(doStep,${StepTime})" #]
  		}
        memoCurrentTime StartTime
        println("basicrobot | doStep StepTime =$StepTime  ")
        run unibo.robot.robotSupport.move( "w" )  //moves a real robot forever !!!
	}
	Transition t0
		whenTimeVar StepTime  -> stepDone
 		whenMsg  obstacle     -> stepFail


	State stepDone{
 		run unibo.robot.robotSupport.move( "h" )  //stop the real robot already done ???
		updateResource [# "basicrobot(stepDone,$StepTime)" #]
   		//emit info : info( stepdone($StepTime) )
   		replyTo step with stepdone : stepdone(ok)
		println("basicrobot | stepDone reply done")
  	}
	Goto work

	State stepFail{
		setDuration Duration from StartTime
		run unibo.robot.robotSupport.move( "h" )  //stop the (real) robot
		[# var TunedDuration = Duration;
			TunedDuration = Duration * 5 / 6
		#]
		println("basicrobot | stepFail duration=$Duration TunedDuration=$TunedDuration")
			run unibo.robot.robotSupport.move( "s" )
			delayVar TunedDuration
			run unibo.robot.robotSupport.move( "h" )
 		updateResource [# "basicrobot(stepFail,$Duration)" #]
 		//emit info : info( stepFail($Duration) )
 		replyTo step with stepfail : stepfail($Duration, obst)
    }
	Goto work

	State endwork{
		updateResource [# "basicrobot(endwork)" #]
 		terminate 1
	}
}

