<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
    <!--
<link rel="stylesheet" type="text/css" href="../css/issStyle1.css">
<script type="text/javascript" src="../css/issStyle.js"></script>
-->
<link rel="stylesheet" type="text/css" href="../docs_common/defaultTemplateStyle.css">
<style>
code>pre { 
    font-family: monospace;
}
dd{
    margin-bottom: 7px;
}
.todo{
    color: orange
}
.centerimg{
    display: block;
    padding-top: 8px;
    padding-bottom: 8px;
    margin-left: auto;
    margin-right: auto;
    width: 90%;
    max-width: 800px;
}
p { margin: 4px 0px; }
dd{ margin-bottom: 8px;}
.newDictWord{ color : purple; }
h6{
    font-size: 1em;
    margin: 18px 0px 9px 0px;
}
</style>
<head>
    <title>Grid vs Boundary walker problem analysis</title>
</head>


<body>
    <div id="top">
    <h1>ISS FINAL PROJECT</h1>
    </div>  
    
    <div class="body"> 
    <div class="remark">
    
        <h3>Il problema della navigazione: <br>
            <p>Uso di un sistema di coordinate  o  boundary walker che raggiunge gli angoli rilevando il contatto con i muri?</p>
        </h3>
        <p>La particolare collocazione delle zone <b>INDOOR</b>, <b>PLASTICBOX</b>, <b>GLASSBOX</b>, <b>HOME</b> e la presenza di un sonar o sensore di impatto sul robot rendono attuabile una 
            soluzione che non richiede l'utilizzo di coordinate: 
            il robot può infatti muoversi all'interno della <b>Service area</b> lungo le pareti, orientandosi semplicemente rilevando le collisioni con le pareti. <br>
            In questa sezione analizziamo i punti a favore dell'utilizzo di un sistema a coordinate e uno senza coordinate:</p>
        <br>
    
        <p>I vantaggi nell'utilizzo di un sistema a coordinate:</p>
        <ul>
            <li>Maggiore flessibilità. Ad esempio nel caso in cui la posizione dei siti non sia più negli angoli, o nel caso il robot debba seguire un percorso ottimo, se ci sono ostacoli nella <b>Service area</b>, ecc... .</li>
            <li>Potenziale riuso di moduli che già abbiamo sviluppato (mapper, planner)</li>
        </ul>
        <p>I vantaggi nell'utilizzo di un sistema senza coordinate:</p>
        <ul>
            <li>Minor complessità, minor costo</li>
            <li>Maggior velocità negli spostamenti, e maggior velocità di reazione a comandi di halt mentre ci si muove in avanti</li>
            <li>Possibile miglior reazione da parte di robot reali che non fatto uso di sistemi in feedback o altro hardware per controllare meglio i propri spostamenti: <br>
                L'errore potrebbe aumentare ad ogni singolo step, mentre la prima soluzione (siccome utilizza il segnale di contatto con il muro) non soffre di questo problema</li>
        </ul>
        <br>
        <p>Per arrivare ad una decisione in merito ad una decisione così importante per la realizzazione del <i>Mover</i>, sono state state analizzate 3 diverse opzioni, che vengono qui descritte: </p>
        
        <h4>OPZIONE 0 - senza coordinate</h4>
        <p>La prima soluzione è anche quella più semplice da comprendere: la strategia sarebbe infatti quella di attivare la giusta macchia a stati, che si occuperà di muovere il robot da una 
            predeterminata posizione X ad una predeterminata posizione Y.</p>
        <p>Pro e Contro:</p>
        <ul>
            <li>+ possibile far gestire ogni singolo caso ad un attore dedicato, dalla semplice implementazione</li>
            <li>- Numero considerevole di casi: supponendo la destinazione sempre diversa dalla posizione attuale sarebbero 3 X 3 = 9 casi. <br>
                Si potrebbe pensare di implementare solo i casi che vengono effettivamente utilizzati dall'applicazione (7: inutile implementare PB→GB e GB→PB), ma la soluzione sarebbe poco riusabile</li>
            <li>- poca flessibilità, potrebbe essere necessario nodificare e testare un gran numero di casi se viene camabiato qualcosa</li>
        </ul> 
        

        <h4>OPZIONE 1 - senza coordinate</h4>
        <p>Utilizziamo una macchina a stati in grado di raggiungere la destinazione facendo fare al robot sempre un giro in senso antiorario. <br>
            Se viene cambiata la destinazione mentre il robot è in movimento, esso non cambia direzione, perchè comunque per raggiugere ogni altro sito procede in senso antiorario, e quindi 
            il prossimo sito che deve essere raggiunto non cambia. <br>
            L'idea è quella di prevedere 4 macrostati, nei quali di volta in volta si decide se il prossimo sito deve essere raggiunto o meno: in pratica si raggiuge il prossimo sito solo se 
            la destinazione non è ancora stata raggiunta. I siti possono essere visti come delle specie di "macrostati" della FSM che implementa il <b>mover</b>.
        </p>
        <img class="centerimg" style="max-width: 700px;" src="docs/_images/transporttrolley_option1_explaination.png"/>
        <p>Pro e Contro:</p>
        <ul>
            <li>+ semplicità</li>
            <li>+ possibile estendere la soluzione appena mostrata per ottenere l'opzione successiva</li>
            <li>- poca flessibilità</li>
            <li>- politica non molto efficiente</li>
        </ul>
        <p>A livello concettuale la macchina a stati che deve essere implementata all'interno di <b>mover</b> sarebbe la seguente:</p>
        <img class="centerimg" src="docs/_images/transporttrolley_option1_verbose_state_machine.png"/>
        <p>È anche possibile implementare lo stesso comportamento mantenendo la posizione corrente all'interno di una variabile (così come per la variabile contenente la posizione di destinazione). 
            In tal caso la macchina verrebbe semplificata parecchio:</p>
        <img class="centerimg" src="docs/_images/transporttrolley_option1_compact_state_machine.png"/>
        
        <h4>OPZIONE 2 - senza coordinate</h4>
        <p>Si tratta di un'estensione dell'opzione 1: il robot è in grado di raggiungere la prossiama destinazione procedendo sia in senso orario che in senso antiorario (sulla base di quello 
            che in quel momento risulta più conveniente). 
            Inoltre il robot può cambiare rotta anche mentre si sta muovendo in avanti. </p>
        <img class="centerimg" style="width: 400px;" src="docs/_images/transporttrolley_option2_explaination.png"/>
        <p>Pro e Contro:</p>
        <ul>
            <li>+ più veloce in alcuni casi. Nello specifico dominio applicativo risulterebbe più vantaggioso solo nel caso in cui vi sia una richiesta dopo aver depositato la plastica</li>
            <li>- più complesso</li>
        </ul>
        <p>La macchina a stati che deve essere implementata all'interno di <b>Transport trolley</b> si complica, perchè tra ogni "macro stato" e l'altro vi sono molti più stati:</p>
        <img class="centerimg" style="max-width: 1100px;" src="docs/_images/transporttrolley_option2_verbose_state_machine.png"/>
        <p>Nell'immagine viene mostrato solo il ramo da <b>HOME</b> a <b>INDOOR</b> e viceversa. Prendiamo il caso in cui si voglia andare da <b>INDOOR</b> a <b>HOME</b>. Per ipotesi il robot, 
            una volta raggiunto un macro stato, si trova sempre orientato verso il prossimo sito in senso antiorario. Siccome conviene in questo caso procedere in senso orario,giriamo il robot verso 
            sinistra per puntarlo verso verso <b>HOME</b>, poi lo facciamo andare avanti (stato <i>forward_clk</i>). Se non arrivano altre destinazioni e rileviamo il contatto con la parete, vuol 
            dire che siamo arrivati in <b>HOME</b>: dobbiamo ora girarci verso <b>INDOOR</b> per poter reagire correttamente alle le prossime richieste. 
            Se invece, mentre si procede da <b>INDOOR</b> a <b>HOME</b> arriva una destinazione per la quale conviene tornare indietro (<b>INDOOR</b> o <b>PLASTICBOX</b>), allora si fa una sorta di 
            inversione ad U (stato <i> u_turn_clk</i>) per tornare al macrostato in cui si era prima.</p>
        <p>E' pur sempre possibile una implementazione più sintetica e compatta se manteniamo la posizione corrente in una variabile:</p>
        <img class="centerimg" style="max-width: 1100px;" src="docs/_images/transporttrolley_option2_compact_state_machine.png"/>
        <p>Anche in questo caso verifichiamo se, mentre si sta procedendo, arriva una nuova destinazione. Se non arriva si procede fino al raggiungimento del sito. Se invece arriva e risulta più 
            conveniente cambiare direzione, si fa una inversione ad U e si torna allo stesso sito dal qaule si è partiti.</p>    
    
        <h4>OPZIONE 3 - con coordinate</h4>
        <p>Il modulo, data la posizione corrente e l'orientamento del robot, fa un certo numero di step e di turn per raggiungere le coordinate di destinazione.</p>
        <p>Pro e Contro:</p>
        <ul>
            <li>+ flessibilità</li>
            <li>+ esiste sw per mappare le dimensioni della stanza (<a href="https://github.com/anatali/issLab2022/tree/main/unibo.mapperQak22">unibo.mapperQak22</a>), per trovare path (<a href="https://github.com/anatali/issLab2022/tree/main/unibo.planner22">unibo.planner22</a>) e per far eseguire il path (<a href="https://github.com/anatali/issLab2022/tree/main/unibo.pathexecutor">unibo.pathexecutor</a>)</li>
            <li>- rischiesto mapping iniziale della servicearea</li>
            <li>- le dimensioni della servicearea potrebbero non essere multiple di RD. È dunque necessaria una logica che (una volta raggiunte le coordinate di destinazione) faccia andare il robot a contatto con la porta, per poter effettuare le operazioni di carico/scarico.</li>
        </ul>
        <img class="centerimg" style="width: 400px;" src="docs/_images/transporttrolley_option3_explaination.png"/>
        <p>Nell'esempio mostrato bisogna</p>
        <ol>
            <li>Eseguire il path che il planner ha trovato</li>
            <li>Girare il robot nella direzione della porta</li>
            <li>Far andare avanti il robot fino al contatto con la parete</li>
            <li>Quando le operazione di carico/scarico sono terminate bisogna far tornare il robot indietro per rimetterlo sull'ultima cella raggiunta</li>
        </ol>
             
        <h4>Scelta: OPZIONE 1</h4>
        <p>Scegliamo la prima soluzione perché è la più semplice e quindi economica, fermo restando che a partire da questa è possibile estenderla per ottenere la seconda versione.<br>
            Inoltre se un giorno nuovi requisiti dovessero imporre l'utilizzo di un sistema di coordinate, verrebbe modificato soltanto il componente "transporttrolley".</p>
    
    </div>