//https://dl.bintray.com/jetbrains/kotlin/eclipse-plugin/0.8.19/
  
System demo0
//mqttBroker "localhost" : 1883 eventTopic "demo0/events"
//mqttBroker "broker.hivemq.com" : 1883 eventTopic "demo0/events"


//-------------------------------------- SONAR -------------------------------------
Dispatch sonaractivate   : info(ARG)
Dispatch sonardeactivate : info(ARG)
Event    alarmsonar : distance( V ) //emitted from sonar infrastructure to sonar actor
Event    sonardata : distance( V )
//----------------------------------------------------------------------------------

//-------------------------------------- LED --------------------------------------------
Event    update_led 	  : update_led(LEDSTATE) // LEDSTATE = ON | OFF | BLINK
// ---------------------------------------------------------------------------------------

// ------------------ CONTEXTS -------------------
//REMEMBER TO PUT datacleaner AND distancefilter IN THE SAME CONTEXT OF basicrobot
Context ctxserver ip [host="192.168.1.138" port=8095]
Context ctxalarm ip  [host="192.168.1.115" port=8097]
// ------------------------------------------------

CodedQActor sonarsimulator     context ctxalarm className "alarmSonar.sonarSimulator"
CodedQActor sonardatasource    context ctxalarm className "alarmSonar.sonarHCSR04Support2021"
CodedQActor datacleaner        context ctxalarm className "alarmSonar.dataCleaner"

CodedQActor robotalarmcontrol  context ctxalarm className "alarmSonar.robotAlarmControl"

CodedQActor ledalarmcontrol    context ctxalarm className "alarmLed.ledAlarmControl"


//-------------------------------------------------------------------- ALARM CTX ----------------------------------------------------------------------
QActor ledcommander context ctxserver {
	State s0 initial {
		printCurrentMessage
		emit update_led : update_led(ON)
	}
	Transition t0 whenTime 1000 -> s1
	State s1 {
		printCurrentMessage
		emit update_led : update_led(BLINK)
	}
	Transition t0 whenTime 1000 -> s2
	State s2 {
		printCurrentMessage
		emit update_led : update_led(OFF)
	}
	Transition t0 whenTime 1000 -> s0
}

QActor sonardisplay context ctxserver {
	State s0 initial {
		printCurrentMessage
		onMsg(sonardata:distance(D)){
			println(payloadArg(0))
		}
	}
	Transition t0 whenEvent sonardata -> s0
}


QActor sonar context ctxalarm {
	[# val simulate       = false
	   val sonarActorName = "sonar"
	#]
	
	State s0 initial {
		printCurrentMessage
		run alarmSonar.configureSonarSubsystem.configureTheSonar(simulate, sonarActorName)
	}
	Goto activateTheSonar
	
	State activateTheSonar{
		printCurrentMessage
		updateResource [# "sonar(activateTheSonar,simulate)" #]
		if[# simulate #]{
			//println("sonar simulator")
			forward sonarsimulator -m sonaractivate : info(ok)
		}else {
			//println("sonar real")
			forward sonardatasource -m sonaractivate : info(ok)  
		}
	}
	Transition t0  whenEvent alarmsonar            -> handleSonarData  
	               whenMsg   sonardeactivate       -> deactivateTheSonar
	
	State deactivateTheSonar{
		printCurrentMessage
		updateResource [# "sonar(deactivateTheSonar,simulate)" #]
		if[# simulate #]{
			//println("sonar simulator")
			forward sonarsimulator -m sonardeactivate : info(ok) 
			//run sonarConfig.activateSonarSimulated() //usingDomain
		}else {
			//println("sonar real")
			forward sonardatasource -m sonardeactivate : info(ok)
		}
	}
	Goto end

	State handleSonarData{
		printCurrentMessage
		onMsg( alarmsonar : distance(D) ){
			[# val D = payloadArg(0) #]
			updateResource [# "sonar(handleSonarData,simulate,${D})" #]
			//println("Distance ${D}")
			emit sonardata : distance($D) //for the application
		}
	}
	Transition t0 whenEvent alarmsonar      -> handleSonarData
				  whenMsg   sonardeactivate -> deactivateTheSonar
		
	State end{
		printCurrentMessage
		updateResource [# "sonar(end,simulate)" #]
		//println("sonar BYE")
		//[# System.exit(0) #]
	}
	Transition t0 whenMsg sonaractivate -> activateTheSonar
}

QActor led context ctxalarm{ 
	[# lateinit var ledM : `it.unibo`.radarSystem22.domain.interfaces.ILed
		`it.unibo`.radarSystem22.domain.utils.DomainSystemConfig.ledGui=false
		`it.unibo`.radarSystem22.domain.utils.DomainSystemConfig.simulation=false
		var newState = ws.LedState.OFF
	#]
	
	State s0 initial {
		discardMsg On
		printCurrentMessage
		updateResource [# "led(initial,${newState})" #]
		//println("${name} STARTS")
		[# ledM = `it.unibo`.radarSystem22.domain.models.LedModel.create() #]
		[# ledM.turnOff()#]
		//[# sysUtil.logMsgs=true #]
 	}
 	Transition t0 whenEvent update_led -> handle_update
 	
 	State handle_update {
 		printCurrentMessage
		onMsg( update_led:update_led(ARG) ){
			[# newState = ws.LedState.valueOf(payloadArg(0)) #]
 			//println("update_led(${newState})")
 		}
 		updateResource [# "led(handle_update,${newState})" #]
 	}
	Goto off if [# newState==ws.LedState.OFF #] else handle_update_switch_1
	State handle_update_switch_1{}
	Goto on if [# newState==ws.LedState.ON #] else handle_update_switch_2
	State handle_update_switch_2{}
	Goto blink_on if [# newState==ws.LedState.BLINK #] else handle_update
 	
 	State off {
 		printCurrentMessage
 		updateResource [# "led(off,${newState})" #]
 		[# unibo.actor22comm.utils.ColorsOut.outappl("${name} - off", unibo.actor22comm.utils.ColorsOut.GREEN)#]
 		[# ledM.turnOff()#]
 	}
 	Transition t0 whenEvent update_led -> handle_update
 	
 	State on {
 		printCurrentMessage
 		updateResource [# "led(on,${newState})" #]
 		[# unibo.actor22comm.utils.ColorsOut.outappl("${name} - on", unibo.actor22comm.utils.ColorsOut.GREEN)#]
 		//println("Led on")
 		[# ledM.turnOn()#]
 	}
 	Transition t0 whenEvent update_led -> handle_update
 	
 	State blink_on {
 		printCurrentMessage
 		updateResource [# "led(blink_on,${newState})" #]
 		[# unibo.actor22comm.utils.ColorsOut.outappl("${name} - on (blinking)", unibo.actor22comm.utils.ColorsOut.GREEN)#]
 		//println("Blinking on")
 		[# ledM.turnOn()#]
 	}
 	Transition t0 whenTime 250 -> blink_off
 					whenEvent update_led -> handle_update
 					
 	State blink_off {
 		printCurrentMessage
 		updateResource [# "led(blink_off,${newState})" #]
 		[# unibo.actor22comm.utils.ColorsOut.outappl("${name} - off (blinking)", unibo.actor22comm.utils.ColorsOut.GREEN)#]
 		//println("Blinking off")
 		[# ledM.turnOff()#]
 	}
 	Transition t0 whenTime 250 -> blink_on
 					whenEvent update_led -> handle_update
}

//-----------------------------------------------------------------------------------------------------------------------------------------------------
