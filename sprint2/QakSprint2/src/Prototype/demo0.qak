//https://dl.bintray.com/jetbrains/kotlin/eclipse-plugin/0.8.19/

System demo0    
//mqttBroker "localhost" : 1883 eventTopic "demo0/events"
//mqttBroker "broker.hivemq.com" : 1883 eventTopic "demo0/events"

//Related to the observer, generated by the runtime
Dispatch coapUpdate: coapUpdate(RESOURCE, VALUE)
Dispatch autoStartSysMsg : autoStartSysMsg(_)

// ------------ wasteservice msgs --------------------
//MATERIAL = PLASTIC | GLASS 
//TRUCKLOAD =  float number
Request depositrequest : depositrequest(MATERIAL, TRUCKLOAD)
Reply loadaccept       : loadaccept(MATERIAL, TRUCKLOAD)
Reply loadrejected     : loadrejected(MATERIAL, TRUCKLOAD)
// ------------------------------------------------------
   
// ------------ transporttrolley msgs -------------------
//RESULT =  OK | ERROR
Request pickup         : pickup(_)
Reply   pickupanswer   : pickupanswer(RESULT)
Request dropout        : dropout(_)
Reply   dropoutanswer  : dropoutanswer(RESULT)
Request moveto         : moveto(POSITION)    //POSITION = INDOOR | PLASTICBOX | GLASSBOX | HOME
Reply   movetoanswer   : movetoanswer(RESULT)
// ------------------------------------------------------

// -------------------- mover msgs ----------------------
//   (same as transporttrolley)
//Request moveto           : moveto(POSITION)    //POSITION = INDOOR | PLASTICBOX | GLASSBOX | HOME
//Reply   movetoanswer     : movetoanswer(RESULT)
// ------------------------------------------------------

// --------------- depositaction msgs -------------------
Request depositaction  : depositaction(MATERIAL) 
Reply   pickupdone	   : pickupdone(_)
Dispatch err		   : err(_)
// ------------------------------------------------------

// ---------------- moveruturn messages -----------------
Request moveruturn     : moveruturn(CURRDIR)  //CURRDIR = ACLK | CLK
Reply moveruturnanswer : moveruturnanswer(RESULT) //RESULT =  OK | ERROR 
// ------------------------------------------------------

// --------------- basicrobotwrapper msgs ---------------
//RESULT =  OK | ERROR 
//MOVE =  w | l | r | h     //the command end when the reply is sent
Request cmdsync   	: cmdsync(MOVE)
Reply cmdanswer   	: cmdanswer(RESULT)
// ------------------------------------------------------

// ------------------ basicrobot msgs -------------------
//MOVE =  w | a | s | d | h    | l | r   //w and s: the robot continues to go until an obstacle is found
Dispatch cmd       	: cmd(MOVE)
Dispatch end       	: end(ARG)
 
Request step       : step( TIME )	
Reply   stepdone   : stepdone(V)  
Reply   stepfail   : stepfail(DURATION, CAUSE)
 
 
Event 	 moving        : moving (F,T)
Event    info          : info( ARG ) 	    //for external components, not coap-observed
Event    sonar         : sonar(DISTANCE,NAME)			//emitted by distancefilter
Dispatch obstacle      : obstacle( ARG ) 	//generated by distancefilter
// ------------------------------------------------------

//-------------------------------------- LED --------------------------------------------
Event    update_led 	  : update_led(LEDSTATE) // LEDSTATE = ON | OFF | BLINK
// ---------------------------------------------------------------------------------------

//-------------------------------------- SONAR -------------------------------------
Dispatch sonaractivate   : info(ARG)
Dispatch sonardeactivate : info(ARG)
Event    alarmsonar : distance( V ) //emitted from sonar infrastructure to sonar actor
Event    local_sonardata : distance( V )
//----------------------------------------------------------------------------------

//-------------------------------------- ALARM -------------------------------------
Event alarm : alarm(_)
Event alarmceased : alarmceased(_)
Dispatch alarm : alarm(_)
Dispatch alarmceased : alarmceased(_)
//----------------------------------------------------------------------------------


// ------------------ CONTEXTS -------------------
//REMEMBER TO PUT datacleaner AND distancefilter IN THE SAME CONTEXT OF basicrobot
Context ctxserver ip [host="localhost" port=8095]
Context ctxrobot ip  [host="127.0.0.1" port=8096]
Context ctxalarm ip  [host="127.0.0.1" port=8097]
// ------------------------------------------------

// ------- basicrobot collision detection ---------
CodedQActor distancefilter context ctxrobot className "rx.distanceFilter"   //Nel caso di robot virtuale semplicemente assorbe eventi obstacle e reinvia dispatch "obstacle:obstacle(virtual)" a basicrobot. Nel caso di robot reali riceve messaggi "sonarRobot" e invia a basicrobot dispatch "obstacle:obstacle(dist)" se vicino, altrimenti sonardata", "sonardata:distance(dist)" se lontano.
// ------------------------------------------------

CodedQActor sonarsimulator     context ctxalarm className "alarmSonar.sonarSimulator"
CodedQActor sonardatasource    context ctxalarm className "alarmSonar.sonarHCSR04Support2021"
CodedQActor datacleaner        context ctxalarm className "alarmSonar.dataCleaner"

CodedQActor robotalarmcontrol  context ctxalarm className "alarmSonar.robotAlarmControl"

CodedQActor ledalarmcontrol    context ctxalarm className "alarmLed.ledAlarmControl"



QActor wasteservice context ctxserver{
	[# lateinit var Material  : ws.Material
	   var TruckLoad : Float = 0F

	   lateinit var RES : String
	   lateinit var TrolleyPos : String   //gbox,pbox,Home,indoor
	#]
	
	State wait initial {
			printCurrentMessage
			updateResource [# "wasteservice(wait,${ws.func.contPB},${ws.func.contGB})" #]
			discardMsg Off
	}
	Transition t0 whenRequest depositrequest -> handle_req
				  whenMsg   err -> error
	
	State handle_req{
		updateResource [# "wasteservice(handle_req,${ws.func.contPB},${ws.func.contGB})" #] 
		printCurrentMessage
		onMsg(depositrequest : depositrequest(MATERIAL, TRUCKLOAD)) {
			[#
				 Material 	= ws.Material.valueOf(payloadArg(0))
				 TruckLoad 	= payloadArg(1).toFloat()
			#]
			println("wasteservice | arrived $TruckLoad Kg of $Material")
			if[# ws.func.checkdepositpossible( Material, TruckLoad ) #]{
				[# ws.func.updateDeposit( Material, TruckLoad ) 
					#]
				println("wasteservice | PB capacity: ${ws.func.contPB}, GB capacity: ${ws.func.contGB}")	
				[# RES="OK"#]
			} else{  
				[# RES="ERR" #]
			}		
		} 
	}
	Goto req_depositaction if [# RES=="OK" #] else rejected
	
	State rejected{
		println("wasteservice | rejected")
		updateResource [# "wasteservice(rejected,${ws.func.contPB},${ws.func.contGB})" #]
		printCurrentMessage
 		replyTo depositrequest with loadrejected : loadrejected($Material,$TruckLoad)
	}
	Goto wait
	
	State req_depositaction{
		println("wasteservice | req_depositaction")
		updateResource [# "wasteservice(req_depositaction,${ws.func.contPB},${ws.func.contGB})" #]
		printCurrentMessage
		request depositaction -m depositaction : depositaction($Material)
	}
	Transition t0 whenReply pickupdone -> chk_depositaction
				  whenMsg   err -> error
	
	State chk_depositaction{
		printCurrentMessage
		updateResource [# "wasteservice(chk_depositaction,${ws.func.contPB},${ws.func.contGB})" #]
		replyTo depositrequest with loadaccept : loadaccept($Material,$TruckLoad)	
	}
	Goto wait
	
	
 	State error {
 		updateResource [# "wasteservice(error,${ws.func.contPB},${ws.func.contGB})" #] 
 		println("wasteservice | error")
 		printCurrentMessage
 	}
}

QActor depositaction context ctxserver{
	[# lateinit var RES : String
	   lateinit var MATERIAL : ws.Material #]
	
	State error {
		updateResource [# "depositaction(error)" #] 
 		println("depositaction | error")
 		printCurrentMessage
 		forward wasteservice -m err : err(_)
	}
	
	State wait initial{
		updateResource [# "depositaction(wait)" #] 
		printCurrentMessage
		discardMsg Off
	}
	Transition t0 whenRequest depositaction -> req_move_indoor
	
	State req_move_indoor {
		printCurrentMessage
		onMsg(depositaction : depositaction(MATERIAL)){
			[# MATERIAL=ws.Material.valueOf(payloadArg(0)) #]
			request transporttrolley -m moveto : moveto(INDOOR)
		}
		updateResource [# "depositaction(req_move_indoor,$MATERIAL)" #] 
	}
	Transition t0 whenReply movetoanswer -> chk_move_indoor
	State chk_move_indoor {
		updateResource [# "depositaction(chk_move_indoor,$MATERIAL)" #] 
		printCurrentMessage
		onMsg(movetoanswer : movetoanswer(RES)){
			[# RES = payloadArg(0); #]
		}
	}
	Goto req_pickup if [# RES=="OK" #] else error
	
	State req_pickup{
		printCurrentMessage
		updateResource [# "depositaction(req_pickup,$MATERIAL)" #] 
		request transporttrolley -m pickup : pickup(_)
	}
	Transition t0 whenReply pickupanswer -> chk_pickup
	State chk_pickup{
		printCurrentMessage
		updateResource [# "depositaction(chk_pickup,$MATERIAL)" #] 
		onMsg(pickupanswer : pickupanswer(RES)){
			[# RES = payloadArg(0); #]
		}
	}
	Goto reply if [# RES=="OK" #] else error
	
	State reply {
		printCurrentMessage
		updateResource [# "depositaction(reply,$MATERIAL)" #] 
		replyTo depositaction with pickupdone: pickupdone(_)
	}
	Goto req_move_container
	
	State req_move_container {
		[# 
			val Position = when(MATERIAL){
			    ws.Material.PLASTIC -> ws.Position.PLASTICBOX
			    ws.Material.GLASS -> ws.Position.GLASSBOX
			} #]
		printCurrentMessage
		updateResource [# "depositaction(req_move_container,$MATERIAL)" #] 
		request transporttrolley -m moveto : moveto($Position)
	}
	Transition t0 whenReply movetoanswer -> chk_move_container
	State chk_move_container{
		printCurrentMessage
		updateResource [# "depositaction(chk_pickup,$MATERIAL)" #] 
		onMsg(movetoanswer : movetoanswer(RES)){
			[# RES = payloadArg(0); #]
		}
	}
	Goto req_dropout if [# RES=="OK" #] else error
	
	State req_dropout{
		updateResource [# "depositaction(req_dropout,$MATERIAL)" #] 
		request transporttrolley -m dropout : dropout(_)
	}
	Transition t0 whenReply dropoutanswer -> chk_dropout
	State chk_dropout{
		printCurrentMessage
		updateResource [# "depositaction(chk_dropout,$MATERIAL)" #] 
		onMsg(dropoutanswer : dropoutanswer(RES)){
			[# RES = payloadArg(0); #]
		}
	}
	Goto next_move if [# RES=="OK" #] else error

	State next_move{
		printCurrentMessage
		updateResource [# "depositaction(next_move,$MATERIAL)" #] 
	}
	Transition t0 whenTime 10 -> move_home
				  whenRequest depositaction -> req_move_indoor
	
	State move_home{
		printCurrentMessage
		updateResource [# "depositaction(move_home,$MATERIAL)" #] 
		request transporttrolley -m moveto : moveto(HOME)
	}
	Transition t0 whenRequest depositaction -> req_move_indoor
				  whenReply   movetoanswer -> wait
}



QActor transporttrolley context ctxrobot{
	[#
		lateinit var RES : String
	#]
	
 	State wait initial {
 		printCurrentMessage
 		updateResource [# "transporttrolley(wait)" #]
 	}
 	Transition toNewState whenRequest pickup -> req_pickup
 						  whenRequest dropout -> req_dropout
 						  whenRequest moveto -> req_move
 						  
 	State req_pickup {
 		printCurrentMessage
 		updateResource [# "transporttrolley(req_pickup)" #]
 		request pickupdropouthandler -m pickup : pickup(_)
 	}
 	Transition toNewState whenReply pickupanswer -> chk_pickup
 	State chk_pickup {
 		printCurrentMessage
 		updateResource [# "transporttrolley(chk_pickup)" #]
 		onMsg( pickupanswer:pickupanswer(RES) ){
 			[# RES = payloadArg(0)#]
 			if[# RES=="OK" #]{
 				replyTo pickup with pickupanswer : pickupanswer(OK)
 			}else{
 				replyTo pickup with pickupanswer : pickupanswer(ERROR)
 			}
 		}
 	}
 	Goto wait
 	
 	State req_dropout {
 		printCurrentMessage
 		updateResource [# "transporttrolley(req_dropout)" #]
 		request pickupdropouthandler -m dropout : dropout(_)
 	}
 	Transition toNewState whenReply dropoutanswer -> chk_dropout
 	State chk_dropout {
 		printCurrentMessage
 		updateResource [# "transporttrolley(chk_dropout)" #] 
 		onMsg( dropoutanswer:dropoutanswer(RES) ){
 			[# RES = payloadArg(0)#]
 			if[# RES=="OK" #]{
 				replyTo dropout with dropoutanswer : dropoutanswer(OK)
 			}else{
 				replyTo dropout with dropoutanswer : dropoutanswer(ERROR)
 			}
 		}
 	}
 	Goto wait
 	
 	State req_move {
 		printCurrentMessage
 		[# var Pos : ws.Position? = null #]
 		onMsg( moveto:moveto(POS) ){
			[# Pos=ws.Position.valueOf(payloadArg(0)) #]
 			//println("transporttrolley | New robot destination: ${pos}")
 			request mover -m moveto : moveto($Pos)
 		}
 		updateResource [# "transporttrolley(req_move,$Pos)" #] 
 	}
 	Transition toNewState whenReply movetoanswer -> chk_move
 							whenRequest moveto -> req_move //cancel current destination and set the new one
 	State chk_move {
 		printCurrentMessage
 		updateResource [# "transporttrolley(chk_move)" #] 
 		onMsg( movetoanswer:movetoanswer(RES) ){
 			[# RES = payloadArg(0)#]
 			if[# RES=="OK" #]{
 				replyTo moveto with movetoanswer : movetoanswer(OK)
 			}else{
 				replyTo moveto with movetoanswer : movetoanswer(ERROR)
 			}
 		}
 	}
 	Goto wait
}


QActor alarmreceiverpickupdropdown context ctxrobot{
	State wait initial {
		printCurrentMessage
		updateResource [# "alarmreceiverpickupdropdown(wait)" #] 
		onMsg(alarm : alarm(_)){
			forward pickupdropouthandler -m alarm : alarm(_)
		}
		onMsg(alarmceased : alarmceased(_)){
			forward pickupdropouthandler -m alarmceased : alarmceased(_)
		}
	}
	Transition t0 whenEvent alarm -> wait
				  whenEvent alarmceased -> wait
}
QActor pickupdropouthandler context ctxrobot{
	
	State handle_prio {
		printCurrentMessage
		updateResource [# "pickupdropouthandler(handle_prio)" #] 
	}
	Transition t0 whenTime 10 -> wait
				whenMsg alarm -> alarm
				whenMsg alarmceased -> handle_prio
	
	State alarm {
		printCurrentMessage
		updateResource [# "pickupdropouthandler(alarm)" #] 
	}
	Transition t0 whenMsg alarmceased -> handle_prio
	
	
	State wait initial {
		discardMsg Off
	 	printCurrentMessage
		updateResource [# "pickupdropouthandler(wait)" #] 
	}
	Transition t0 whenRequest dropout -> do_dropout
					whenRequest pickup -> do_pickup
					whenMsg alarm -> alarm
	
	// --------------------- HANDLING DROPOUT ----------------------
	State do_dropout {
		printCurrentMessage
		updateResource [# "pickupdropouthandler(do_dropout)" #]
	}
	Transition t0 whenTime 1000 -> done_dropout
				  whenMsg alarm -> halt_dropout
	State halt_dropout {
		printCurrentMessage
		updateResource [# "pickupdropouthandler(halt_dropout)" #]
	}
	Transition t0 whenMsg alarmceased -> resume_dropout
	State resume_dropout {
		printCurrentMessage
		updateResource [# "pickupdropouthandler(resume_dropout)" #]
	}
	Transition t0 whenTime 1000 -> done_dropout
	// --------------------------------------------------------------
	
	// ---------------------- HANDLING PICKUP -----------------------
	State do_pickup {
		printCurrentMessage
		updateResource [# "pickupdropouthandler(do_pickup)" #]
	}
	Transition t0 whenTime 1000 -> done_pickup
				  whenMsg alarm -> halt_pickup
	State halt_pickup {
		printCurrentMessage
		updateResource [# "pickupdropouthandler(halt_pickup)" #]
	}
	Transition t0 whenMsg alarmceased -> resume_pickup
	State resume_pickup {
		printCurrentMessage
		updateResource [# "pickupdropouthandler(resume_pickup)" #]
	}
	Transition t0 whenTime 1000 -> done_pickup
	// --------------------------------------------------------------
	
	State done_dropout {
		printCurrentMessage
		updateResource [# "pickupdropouthandler(done_dropout)" #]
		replyTo dropout with dropoutanswer:dropoutanswer(OK)
	}
	Goto wait
	
	State done_pickup {
		printCurrentMessage
		updateResource [# "pickupdropouthandler(done_pickup)" #]
		replyTo pickup with pickupanswer:pickupanswer(OK)
	}
	Goto wait
}

//RECEIVES moveto(POS) MESSAGES, MOVES THE ROBOT INTO POS, AND REPLY WITH movetoanswer(RES)
//basically it translates high level move to the final position, into low level robot moves
QActor mover context ctxrobot{
	[# var DEST = ws.Position.HOME
	   var CURRPOS = ws.Position.HOME
	   var CURRDIR = "ACLK" // ACLK | CLK
	   lateinit var RES : String
	#]
	
	State wait initial {
		discardMsg Off
		printCurrentMessage
		updateResource [# "mover(wait,$CURRPOS,$DEST,$CURRDIR)" #]
	}
	Transition t0 whenRequest moveto -> handle
	
	State handle {
		printCurrentMessage
		onMsg( moveto:moveto(POS) ){
			[# DEST = ws.Position.valueOf(payloadArg(0))#]
			if [# DEST==CURRPOS#] {
				replyTo moveto with movetoanswer : movetoanswer(OK)
			}
		}
		updateResource [# "mover(handle,$CURRPOS,$DEST,$CURRDIR)" #]
	}
	Goto aclk_or_clk if [# DEST!=CURRPOS #] else wait //if the destination is different form the current position, reach next corner
	
	State aclk_or_clk {
		printCurrentMessage
		updateResource [# "mover(aclk_or_clk,$CURRPOS,$DEST,$CURRDIR)" #]
	}
	Goto prepare_aclk if [# DEST==ws.func.nextPos(CURRPOS) || DEST==ws.func.nextPos(ws.func.nextPos(CURRPOS)) #] else prepare_clk //decide which direction to take depending on the current position and destination
	
	//------------------------------- REACHING NEXT CORNER IN ANTICLOCKWISE DIRECTION -------------------------------
	State prepare_aclk {
		printCurrentMessage
		updateResource [# "mover(prepare_aclk,$CURRPOS,$DEST,$CURRDIR)" #]
	}
	Goto req_pre_turn_aclk if [# CURRDIR!="ACLK" #] else req_forward_aclk
	
	State req_pre_turn_aclk {
		printCurrentMessage
		updateResource [# "mover(req_pre_turn_aclk,$CURRPOS,$DEST,$CURRDIR)" #]
		request basicrobotwrapper -m cmdsync : cmdsync(r)
	}
	Transition t0 whenReply cmdanswer -> chk_pre_turn_aclk
	State chk_pre_turn_aclk {
		printCurrentMessage
		updateResource [# "mover(chk_pre_turn_aclk,$CURRPOS,$DEST,$CURRDIR)" #]
		onMsg( cmdanswer:cmdanswer(RES) ){
			[# RES = payloadArg(0)#]
		}
	}
	Goto req_forward_aclk if [# RES=="OK" #] else error
	
	State req_forward_aclk {
		printCurrentMessage
		[# CURRDIR="ACLK" #]
		updateResource [# "mover(req_forward_aclk,$CURRPOS,$DEST,$CURRDIR)" #]
		request basicrobotwrapper -m cmdsync : cmdsync(w)
	}
	Transition t0 whenReply cmdanswer -> chk_forward_aclk //wall reached
					whenRequest moveto -> set_new_dest_aclk //new position arrived
	State chk_forward_aclk {
		printCurrentMessage
		updateResource [# "mover(chk_forward_aclk,$CURRPOS,$DEST,$CURRDIR)" #]
		onMsg( cmdanswer:cmdanswer(RES) ){
			[# RES = payloadArg(0)#]
		}
	}
	Goto req_post_turn_aclk if [# RES=="OK" #] else error
	State set_new_dest_aclk { //set new position and decide if it's convenient to change direction
		printCurrentMessage
		onMsg( moveto:moveto(POS) ){
			[# DEST = ws.Position.valueOf(payloadArg(0))#]
		}
		updateResource [# "mover(set_new_dest_aclk,$CURRPOS,$DEST,$CURRDIR)" #]
	}
	Goto req_forward_aclk if [# DEST==ws.func.nextPos(CURRPOS) || DEST==ws.func.nextPos(ws.func.nextPos(CURRPOS)) #] //continue with the current route if the destination is the position we are currently reaching ( nextPos(CURRPOS) ) or the next one ( nextPos(nextPos(CURRPOS)) )
		else req_u_turn //otherwise it's more convenient to return back return back
	
	State req_post_turn_aclk {
		printCurrentMessage
		updateResource [# "mover(req_post_turn_aclk,$CURRPOS,$DEST,$CURRDIR)" #]
		request basicrobotwrapper -m cmdsync : cmdsync(l)
	}
	Transition t0 whenReply cmdanswer -> chk_post_turn_aclk
	State chk_post_turn_aclk {
		printCurrentMessage
		updateResource [# "mover(chk_post_turn_aclk,$CURRPOS,$DEST,$CURRDIR)" #]
		onMsg( cmdanswer:cmdanswer(RES) ){
			[# RES = payloadArg(0)#]
		}
	}
	Goto update_aclk if [# RES=="OK" #] else error
	
	State update_aclk {
		printCurrentMessage
		[# CURRPOS=ws.func.nextPos(CURRPOS) #]
		updateResource [# "mover(update_aclk,$CURRPOS,$DEST,$CURRDIR)" #]
	}
	Goto reply	
	//---------------------------------------------------------------------------------------------------------------
	
	//--------------------------------- REACHING NEXT CORNER IN CLOCKWISE DIRECTION ---------------------------------
	State prepare_clk {
		printCurrentMessage
		updateResource [# "mover(prepare_clk,$CURRPOS,$DEST,$CURRDIR)" #]
	}
	Goto req_pre_turn_clk if [# CURRDIR!="CLK" #] else req_forward_clk
	
	State req_pre_turn_clk {
		printCurrentMessage
		updateResource [# "mover(req_pre_turn_clk,$CURRPOS,$DEST,$CURRDIR)" #]
		request basicrobotwrapper -m cmdsync : cmdsync(l)
	}
	Transition t0 whenReply cmdanswer -> chk_pre_turn_clk
	State chk_pre_turn_clk {
		printCurrentMessage
		updateResource [# "mover(chk_pre_turn_clk,$CURRPOS,$DEST,$CURRDIR)" #]
		onMsg( cmdanswer:cmdanswer(RES) ){
			[# RES = payloadArg(0)#]
		}
	}
	Goto req_forward_clk if [# RES=="OK" #] else error
	
	State req_forward_clk {
		printCurrentMessage
		[# CURRDIR="CLK" #]
		updateResource [# "mover(req_forward_clk,$CURRPOS,$DEST,$CURRDIR)" #]
		request basicrobotwrapper -m cmdsync : cmdsync(w)
	}
	Transition t0 whenReply cmdanswer -> chk_forward_clk //wall reached
					whenRequest moveto -> set_new_dest_clk //new position arrived
	State chk_forward_clk {
		printCurrentMessage
		updateResource [# "mover(chk_forward_clk,$CURRPOS,$DEST,$CURRDIR)" #]
		onMsg( cmdanswer:cmdanswer(RES) ){
			[# RES = payloadArg(0)#]
		}
	}
	Goto req_post_turn_clk if [# RES=="OK" #] else error
	State set_new_dest_clk { //set new position and decide if it's convenient to change direction
		printCurrentMessage
		onMsg( moveto:moveto(POS) ){
			[# DEST = ws.Position.valueOf(payloadArg(0))#]
		}
		updateResource [# "mover(set_new_dest_clk,$CURRPOS,$DEST,$CURRDIR)" #]
	}
	Goto req_forward_clk if [# DEST==ws.func.prevPos(CURRPOS) || DEST==ws.func.prevPos(ws.func.prevPos(CURRPOS)) #] //continue with the current route if the destination is the position we are currently reaching ( nextPos(CURRPOS) ) or the next one ( nextPos(nextPos(CURRPOS)) )
		else req_u_turn //otherwise it's more convenient to return back return back
	
	State req_post_turn_clk {
		printCurrentMessage
		updateResource [# "mover(req_post_turn_clk,$CURRPOS,$DEST,$CURRDIR)" #]
		request basicrobotwrapper -m cmdsync : cmdsync(r)
	}
	Transition t0 whenReply cmdanswer -> chk_post_turn_clk
	State chk_post_turn_clk {
		printCurrentMessage
		updateResource [# "mover(chk_post_turn_clk,$CURRPOS,$DEST,$CURRDIR)" #]
		onMsg( cmdanswer:cmdanswer(RES) ){
			[# RES = payloadArg(0)#]
		}
	}
	Goto update_clk if [# RES=="OK" #] else error
	
	State update_clk {
		printCurrentMessage
		[# CURRPOS=ws.func.prevPos(CURRPOS) #]
		updateResource [# "mover(update_clk,$CURRPOS,$DEST,$CURRDIR)" #]
	}
	Goto reply
	//---------------------------------------------------------------------------------------------------------------
	
	//-------------------------------------- U TURN ------------------------------------------
	State req_u_turn {
		printCurrentMessage
		request moveruturn -m moveruturn : moveruturn($CURRDIR)
		updateResource [# "mover(req_u_turn,$CURRPOS,$DEST,$CURRDIR)" #]
	}
	Transition t0 whenReply moveruturnanswer -> chk_u_turn
					whenReply movetoanswer -> req_u_turn //consume possible incoming movetoanswer due to critical race condition (new position for witch u turn is needed arrived, but the robot reaches the wall: the basicrobotwrapper replies before receiving the new commands from moveruturn)
	State chk_u_turn {
		printCurrentMessage
		onMsg( moveruturnanswer:moveruturnanswer(RES) ){
			[# RES = payloadArg(0)#]
		}
		[# CURRDIR = when(CURRDIR){
				"ACLK" -> "CLK"
				"CLK"  -> "ACLK"
				else -> {println("moveruturn | error: unknow direction $CURRDIR"); ""}
		   } #]
		updateResource [# "mover(chk_u_turn,$CURRPOS,$DEST,$CURRDIR)" #]
	}
	Goto reply if [# RES=="OK" #] else error
	//-----------------------------------------------------------------------------------------
	
	State reply {
		printCurrentMessage
		if[# CURRPOS==DEST #]{
			replyTo moveto with movetoanswer : movetoanswer(OK)
		}
		updateResource [# "mover(reply,$CURRPOS,$DEST,$CURRDIR)" #]
	}
	Transition t0 whenTime 10 -> handle //no messages, go to handle
					whenRequest moveto -> handle //new destination, consume the message while going to handle
	
	State error{
		printCurrentMessage
		updateResource [# "mover(error,$CURRPOS,$DEST,$CURRDIR)" #]
		replyTo moveto with movetoanswer : movetoanswer(ERROR)
		println("mover | ERROR STATE")
	}
}

QActor moveruturn context ctxrobot{
	[#  lateinit var RES : String
		var ENDDIR : String? = null #]
	
	State wait initial {
		discardMsg On
		printCurrentMessage
		updateResource [# "moveruturn(wait,$ENDDIR)" #]
	}
	Transition t0 whenRequest moveruturn -> req_halt
	
	State req_halt {
		printCurrentMessage
		onMsg( moveruturn:moveruturn(DIR) ){
			[# ENDDIR = when(payloadArg(0)){
				"ACLK" -> "CLK"
				"CLK"  -> "ACLK"
				else -> {println("moveruturn | error: unknow direction"); ""}
			   } #]
		}
		updateResource [# "moveruturn(req_halt,$ENDDIR)" #]
		request basicrobotwrapper -m cmdsync : cmdsync(h)
	}
	Transition t0 whenReply cmdanswer -> chk_halt
	State chk_halt {
		printCurrentMessage
		updateResource [# "moveruturn(chk_halt,$ENDDIR)" #]
		onMsg( cmdanswer:cmdanswer(RES) ){
			[# RES = payloadArg(0)#]
		}
	}
	Goto req_turn_1 if [# RES=="OK" #] else error
	
	State req_turn_1 {
		printCurrentMessage
		updateResource [# "moveruturn(req_turn_1,$ENDDIR)" #]
		request basicrobotwrapper -m cmdsync : cmdsync(l)
	}
	Transition t0 whenReply cmdanswer -> chk_turn_1
	State chk_turn_1 {
		printCurrentMessage
		updateResource [# "moveruturn(chk_turn_1,$ENDDIR)" #]
		onMsg( cmdanswer:cmdanswer(RES) ){
			[# RES = payloadArg(0)#]
		}
	}
	Goto req_turn_2 if [# RES=="OK" #] else error
	
	State req_turn_2 {
		printCurrentMessage
		updateResource [# "moveruturn(req_turn_2,$ENDDIR)" #]
		request basicrobotwrapper -m cmdsync : cmdsync(l)
	}
	Transition t0 whenReply cmdanswer -> chk_turn_2
	State chk_turn_2 {
		printCurrentMessage
		updateResource [# "moveruturn(chk_turn_2,$ENDDIR)" #]
		onMsg( cmdanswer:cmdanswer(RES) ){
			[# RES = payloadArg(0)#]
		}
	}
	Goto req_forward if [# RES=="OK" #] else error
	
	State req_forward {
		printCurrentMessage
		updateResource [# "moveruturn(req_forward,$ENDDIR)" #]
		request basicrobotwrapper -m cmdsync : cmdsync(w)
	}
	Transition t0 whenReply cmdanswer -> chk_forward
	State chk_forward {
		printCurrentMessage
		updateResource [# "moveruturn(chk_forward,$ENDDIR)" #]
		onMsg( cmdanswer:cmdanswer(RES) ){
			[# RES = payloadArg(0)#]
		}
	}
	Goto req_final_turn if [# RES=="OK" #] else error
	
	State req_final_turn {
		printCurrentMessage
		updateResource [# "moveruturn(req_final_turn,$ENDDIR)" #]
		if [# ENDDIR == "ACLK" #] {
			request basicrobotwrapper -m cmdsync : cmdsync(l)
		}else{ //ENDDIR = "CLK"
			request basicrobotwrapper -m cmdsync : cmdsync(r)
		}
	}
	Transition t0 whenReply cmdanswer -> chk_final_turn
	State chk_final_turn {
		printCurrentMessage
		updateResource [# "moveruturn(chk_final_turn,$ENDDIR)" #]
		onMsg( cmdanswer:cmdanswer(RES) ){
			[# RES = payloadArg(0)#]
		}
	}
	Goto reply if [# RES=="OK" #] else error
	
	State reply {
		printCurrentMessage
		replyTo moveruturn with moveruturnanswer : moveruturnanswer(OK)
		updateResource [# "moveruturn(reply,$ENDDIR)" #]
	}
	Goto wait
	
	State error{
		printCurrentMessage
		updateResource [# "moveruturn(error,$ENDDIR)" #]
		replyTo moveruturn with moveruturnanswer : moveruturnanswer(ERROR)
		println("moveruturn | ERROR STATE")
	}
}

QActor alarmreceiverbasicrobot context ctxrobot{
	State wait initial {
		printCurrentMessage
		updateResource [# "alarmreceiverpickupdropdown(wait)" #] 
		onMsg(alarm : alarm(_)){
			forward basicrobotwrapper -m alarm : alarm(_)
		}
		onMsg(alarmceased : alarmceased(_)){
			forward basicrobotwrapper -m alarmceased : alarmceased(_)
		}
	}
	Transition t0 whenEvent alarm -> wait
				  whenEvent alarmceased -> wait
}
QActor basicrobotwrapper context ctxrobot{
	[# var MOVE : ws.Move? = null  #]
	
	State handle_prio {
		printCurrentMessage
		updateResource [# "basicrobotwrapper(handle_prio)" #] 
	}
	Transition t0 whenTime 10 -> wait
				whenMsg alarm -> alarm
				whenMsg alarmceased -> handle_prio
	
	State alarm {
		printCurrentMessage
		updateResource [# "basicrobotwrapper(alarm)" #] 
	}
	Transition t0 whenMsg alarmceased -> handle_prio
	
	State wait initial {
		discardMsg Off
	 	printCurrentMessage
		updateResource [# "basicrobotwrapper(wait)" #] 
	}
	Transition t0 whenRequest cmdsync -> handle
					whenMsg alarm -> alarm
					
	State handle {
	 	printCurrentMessage
	 	onMsg( cmdsync:cmdsync(MOVE) ){
			[# MOVE = ws.Move.valueOf(payloadArg(0)) #]
		}
		updateResource [# "basicrobotwrapper(handle,$MOVE)" #]
	}
	Goto forward_cmd if [# MOVE==ws.Move.w #] else other_cmd
	
	State other_cmd {
		printCurrentMessage
		updateResource [# "basicrobotwrapper(other_cmd,$MOVE)" #]
		[# val MoveStr = MOVE.toString()#]
		forward basicrobotlorisdavide -m cmd : cmd($MoveStr)
		if[# MOVE==ws.Move.l || MOVE==ws.Move.r #]{
			delay 500 //wait for turn to complete
		}
		delay 100
		replyTo cmdsync with cmdanswer : cmdanswer(OK)
	}
	Goto handle_prio
	
	State forward_cmd {
		printCurrentMessage
		updateResource [# "basicrobotwrapper(forward_cmd)" #]
		forward basicrobotlorisdavide -m cmd : cmd(w)
	}
	Transition t0 whenEvent info -> collision
					whenRequest cmdsync -> handle
					whenMsg alarm -> halt_forward
					
	State halt_forward {
		printCurrentMessage
		updateResource [# "basicrobotwrapper(halt_forward)" #]
		forward basicrobotlorisdavide -m cmd : cmd(h)
	}
	Transition t0 whenEvent info -> halt_collision
					whenMsg alarmceased -> forward_cmd
					
	State halt_collision {
		printCurrentMessage
		updateResource [# "basicrobotwrapper(halt_collision)" #]
	}
	Transition t0 whenMsg alarmceased -> collision
	
	State collision {
		printCurrentMessage
		updateResource [# "basicrobotwrapper(collision)" #]
		replyTo cmdsync with cmdanswer : cmdanswer(OK) 
	}
	Goto handle_prio
	
}

QActor basicrobotlorisdavide context ctxrobot{
[#
  var StepTime      = 0L
  var StartTime     = 0L
  var Duration      = 0L
  var ExpectingCollision = false
  //var RobotType     = "" 
  var CurrentMove   = "unkknown"
#]  
 	State s0 initial { 	      
 		discardMsg Off  //WE want receive any msg
		println("basicrobot | START")	
 		qrun unibo.robot.robotSupport.create(myself,"basicrobotConfig.json")	
 		//[# RobotType = unibo.robot.robotSupport.robotKind #]
 		/*delay 1000  //give to the realsonar the time to start
        if[# RobotType != "virtual" #]{
        	[# var robotsonar = context!!.hasActor("realsonar")  
        	   if(robotsonar != null) unibo.robot.robotSupport.createSonarPipe(robotsonar) 
        	#] 
  		}//The Virtual robot sonar is created in virtualrobotSupport2021*/
 
  		//run unibo.robot.robotSupport.move( "l" )    //synch
 		//run unibo.robot.robotSupport.move( "r" )	//synch
    		//run unibo.robot.robotSupport.move( "w" )    //asynch 
 		updateResource [# "basicrobotlorisdavide(s0)" #]
 	}
	Goto work

	State work{
		println("basicrobot | waiting .............. ")
		updateResource [# "basicrobotlorisdavide(work)" #]
	}
	Transition t1   whenMsg     cmd       -> execcmd
					whenRequest step      -> doStep
					whenMsg    obstacle   -> handleObstacle  //in virtualrobot caused by the move w/s
					//whenEvent sonar       -> handleSonar
				  	whenMsg     end       -> endwork

	State execcmd{
		printCurrentMessage
		onMsg( cmd : cmd(MOVE) ){
  			//activate the motors
  			[# val Move = payloadArg(0) #]
  			[# if(Move=="w") ExpectingCollision=true #]
  			println("basicrobot | executing '${Move}'")
			run unibo.robot.robotSupport.move( Move )
			updateResource [# "basicrobotlorisdavide(execcmd,$Move)" #]
		}
	 }
	 Goto work

	State handleObstacle{
		printCurrentMessage
		//println("basicrobot | handleObstacle")
		if[# ExpectingCollision #]{
			[# ExpectingCollision=false #]
			run unibo.robot.robotSupport.move( "h" )
			delay 600
			updateResource [# "basicrobotlorisdavide(handleObstacle,${CurrentMove})" #]
			/*if[# CurrentMove == "w"#]{
			//back to avoid emission of obstacle again if real robot moving forward !!!
			//if[# RobotType != "virtual" #]{	//is it better to embed this behavior in the support?
				run unibo.robot.robotSupport.move( "s" )
				delay 100
				run unibo.robot.robotSupport.move( "h" )
	 		}*/
	 		emit info : info( obstacledoing(w) )
	 		//forward transporttrolley -m wall : wall( obstacledoing(w) )
		}
	}
	Goto work

	/*State handleSonar{
		printCurrentMessage
	}
	Goto work*/

   	State doStep{
 		printCurrentMessage
		onMsg( step : step( T ) ){
			[#	StepTime = payloadArg(0).toLong() 	#]
			updateResource [# "basicrobotlorisdavide(doStep,${StepTime})" #]
  		}
        memoCurrentTime StartTime
        println("basicrobot | doStep StepTime =$StepTime  ")
        run unibo.robot.robotSupport.move( "w" )  //moves a real robot forever !!!
	}
	Transition t0
		whenTimeVar StepTime  -> stepDone
 		whenMsg  obstacle     -> stepFail


	State stepDone{
 		run unibo.robot.robotSupport.move( "h" )  //stop the real robot already done ???
		updateResource [# "basicrobotlorisdavide(stepDone,$StepTime)" #]
   		//emit info : info( stepdone($StepTime) )
   		replyTo step with stepdone : stepdone(ok)
		println("basicrobot | stepDone reply done")
  	}
	Goto work

	State stepFail{
		setDuration Duration from StartTime
		run unibo.robot.robotSupport.move( "h" )  //stop the (real) robot
		[# var TunedDuration = Duration;
			TunedDuration = Duration * 5 / 6
		#]
		println("basicrobot | stepFail duration=$Duration TunedDuration=$TunedDuration")
			run unibo.robot.robotSupport.move( "s" )
			delayVar TunedDuration
			run unibo.robot.robotSupport.move( "h" )
 		updateResource [# "basicrobotlorisdavide(stepFail,$Duration)" #]
 		//emit info : info( stepFail($Duration) )
 		replyTo step with stepfail : stepfail($Duration, obst)
    }
	Goto work

	State endwork{
		updateResource [# "basicrobotlorisdavide(endwork)" #]
 		terminate 1
	}
}


//-------------------------------------------------------------------- ALARM CTX ----------------------------------------------------------------------

QActor sonarlorisdavide context ctxalarm {
	[# val simulate       = true
	   val sonarActorName = name
	   var active = false
	   var init = false
	#]
	
	State s0 initial {
		printCurrentMessage
		if[# !init #]{ //prevent re-initialization
			[# init=true #]
			run alarmSonar.configureSonarSubsystem.configureTheSonar(simulate, sonarActorName)
		}
	}
	Goto activateTheSonar
	
	State activateTheSonar{
		printCurrentMessage
		updateResource [# "sonarlorisdavide(activateTheSonar,simulate)" #]
		if[# !init #]{ //if a message arrives before autoStartSysMsg s0 action will never be executed
			[# init=true #]
			run alarmSonar.configureSonarSubsystem.configureTheSonar(simulate, sonarActorName)
		}
		if[# !active #]{
			if[# simulate #]{
				//println("sonar simulator")
				forward sonarsimulator -m sonaractivate : info(ok)
			}else {
				//println("sonar real")
				forward sonardatasource -m sonaractivate : info(ok)  
			}
			[# active=true #]
		}
	}
	Transition t0  whenEvent alarmsonar            -> handleSonarData  
	               whenMsg   sonardeactivate       -> deactivateTheSonar
	
	State deactivateTheSonar{
		printCurrentMessage
		updateResource [# "sonarlorisdavide(deactivateTheSonar,simulate)" #]
		if[# active #]{
			if[# simulate #]{
				//println("sonar simulator")
				forward sonarsimulator -m sonardeactivate : info(ok) 
				//run sonarConfig.activateSonarSimulated() //usingDomain
			}else {
				//println("sonar real")
				forward sonardatasource -m sonardeactivate : info(ok)  
			}
			[# active=false #]
		}
	}
	Goto end
  
  	State handleSonarData{
  		printCurrentMessage
  		onMsg( alarmsonar : distance(D) ){
   			[# val D = payloadArg(0) #]
   			updateResource [# "sonarlorisdavide(handleSonarData,simulate,${D})" #]
  			//println("Distance ${D}")
  			emit local_sonardata : distance($D) //for the application
  		}
  	}
   	Transition t0 whenEvent alarmsonar      -> handleSonarData
   				  whenMsg   sonardeactivate -> deactivateTheSonar
   		
	State end{
		printCurrentMessage
		updateResource [# "sonarlorisdavide(end,simulate)" #]
		//println("sonar BYE")
		//[# System.exit(0) #]
	}
	Transition t0 whenMsg sonaractivate -> activateTheSonar
}

QActor alarmemitter context ctxalarm {
	[# var alarm = false #]
	State wait initial {
		printCurrentMessage
		updateResource [# "alarmemitter(wait)" #] 
		onMsg(local_sonardata : distance(D)){
			if[# payloadArg(0).toInt() <= ws.const.DLIMIT && !alarm #]{
				emit alarm : alarm(_)
				[# alarm = true #]
			}
			if[# payloadArg(0).toInt() > ws.const.DLIMIT && alarm #]{
				emit alarmceased : alarmceased(_)
				[# alarm = false #]
			}
		}
	}
	Transition t0 whenEvent local_sonardata -> wait
}

/*QActor testledalarmcontrol context ctxalarm { //ctxobserver ctxboundaryqak30{
	State s0 initial{
		observeResource basicrobotwrapper
		observeResource mover
		observeResource pickupdropouthandler
	} 
	Transition t0 whenMsg coapUpdate -> handleUpdate
	State handleUpdate{
		onMsg (coapUpdate : coapUpdate(RESOURCE, VALUE)) {
			println("update: ${payloadArg(0)} ${payloadArg(1)}")
		}
	}
	Transition t0 whenMsg coapUpdate -> handleUpdate
}*/

QActor led context ctxalarm{ 
	[# var ledM : `it.unibo`.radarSystem22.domain.interfaces.ILed? = null
		`it.unibo`.radarSystem22.domain.utils.DomainSystemConfig.ledGui=true
		var newState : ws.LedState? = null
	#]
	
	State s0 initial {
		discardMsg On
		printCurrentMessage
		updateResource [# "led(initial,OFF)" #]
		//println("${name} STARTS")
		if[# ledM == null #]{
			[# ledM = `it.unibo`.radarSystem22.domain.models.LedModel.create().also{ it.turnOff() } #]
		}
		//[# sysUtil.logMsgs=true #]
 	}
 	Transition t0 whenEvent update_led -> handle_update
 	
 	State handle_update {
 		printCurrentMessage
		onMsg( update_led:update_led(ARG) ){
			[# newState = ws.LedState.valueOf(payloadArg(0)) #]
			if[# ledM == null #]{
				[# ledM = `it.unibo`.radarSystem22.domain.models.LedModel.create().also{ it.turnOff() } #] //apparently if a message arrives before the startMsg, the s0 action is not executed
			}
 			//println("update_led(${newState})")
 		}
 		updateResource [# "led(handle_update,${newState})" #]
 	}
	Goto off if [# newState==ws.LedState.OFF #] else handle_update_switch_1
	State handle_update_switch_1{}
	Goto on if [# newState==ws.LedState.ON #] else handle_update_switch_2
	State handle_update_switch_2{}
	Goto blink_on if [# newState==ws.LedState.BLINK #] else s0
 	
 	State off {
 		printCurrentMessage
 		updateResource [# "led(off,${newState})" #]
 		[# unibo.actor22comm.utils.ColorsOut.outappl("${name} - off", unibo.actor22comm.utils.ColorsOut.GREEN)#]
 		[# ledM!!.turnOff()#]
 	}
 	Transition t0 whenEvent update_led -> handle_update
 	
 	State on {
 		printCurrentMessage
 		updateResource [# "led(on,${newState})" #]
 		[# unibo.actor22comm.utils.ColorsOut.outappl("${name} - on", unibo.actor22comm.utils.ColorsOut.GREEN)#]
 		//println("Led on")
 		[# ledM!!.turnOn()#]
 	}
 	Transition t0 whenEvent update_led -> handle_update
 	
 	State blink_on {
 		printCurrentMessage
 		updateResource [# "led(blink_on,${newState})" #]
 		[# unibo.actor22comm.utils.ColorsOut.outappl("${name} - on (blinking)", unibo.actor22comm.utils.ColorsOut.GREEN)#]
 		//println("Blinking on")
 		[# ledM!!.turnOn()#]
 	}
 	Transition t0 whenTime 250 -> blink_off
 					whenEvent update_led -> handle_update
 					
 	State blink_off {
 		printCurrentMessage
 		updateResource [# "led(blink_off,${newState})" #]
 		[# unibo.actor22comm.utils.ColorsOut.outappl("${name} - off (blinking)", unibo.actor22comm.utils.ColorsOut.GREEN)#]
 		//println("Blinking off")
 		[# ledM!!.turnOff()#]
 	}
 	Transition t0 whenTime 250 -> blink_on
 					whenEvent update_led -> handle_update
}

//-----------------------------------------------------------------------------------------------------------------------------------------------------


QActor commandissuerfortests context ctxrobot{
	[#
		lateinit var RES : String
	#]
	
	State wait initial {
		printCurrentMessage
		discardMsg Off
		updateResource [# "commandissuerfortests(wait)" #]
	}
	Transition toNewState whenRequest pickup -> req_pickup
						  whenRequest dropout -> req_dropout
						  whenRequest cmdsync -> req_cmdsync
						  
	State req_pickup {
		printCurrentMessage
		updateResource [# "commandissuerfortests(req_pickup)" #]
		request pickupdropouthandler -m pickup : pickup(_)
	}
	Transition toNewState whenReply pickupanswer -> chk_pickup
	State chk_pickup {
		printCurrentMessage
		updateResource [# "commandissuerfortests(chk_pickup)" #]
		onMsg( pickupanswer:pickupanswer(RES) ){
			[# RES = payloadArg(0)#]
			if[# RES=="OK" #]{
			replyTo pickup with pickupanswer : pickupanswer(OK)
			}else{
				replyTo pickup with pickupanswer : pickupanswer(ERROR)
			}
		}
	}
	Goto wait
	
	State req_dropout {
		printCurrentMessage
		updateResource [# "commandissuerfortests(req_dropout)" #]
		request pickupdropouthandler -m dropout : dropout(_)
	}
	Transition toNewState whenReply dropoutanswer -> chk_dropout
	State chk_dropout {
		printCurrentMessage
		updateResource [# "commandissuerfortests(chk_dropout)" #] 
		onMsg( dropoutanswer:dropoutanswer(RES) ){
			[# RES = payloadArg(0)#]
		if[# RES=="OK" #]{
				replyTo dropout with dropoutanswer : dropoutanswer(OK)
			}else{
				replyTo dropout with dropoutanswer : dropoutanswer(ERROR)
			}
		}
	}
	Goto wait

	State req_cmdsync {
		printCurrentMessage
		[# var Move : ws.Move? = null #]
		onMsg( cmdsync:cmdsync(MOVE) ){
			[# Move=ws.Move.valueOf(payloadArg(0)) #]
			request basicrobotwrapper -m cmdsync : cmdsync($Move)
		}
		updateResource [# "commandissuerfortests(req_cmdsync,$Move)" #] 
	}
	Transition toNewState whenReply cmdanswer -> chk_cmdsync
	State chk_cmdsync {
		printCurrentMessage
		updateResource [# "commandissuerfortests(chk_cmdsync)" #] 
		onMsg( cmdanswer:cmdanswer(RES) ){
			[# RES = payloadArg(0)#]
			if[# RES=="OK" #]{
				replyTo cmdsync with cmdanswer : cmdanswer(OK)
			}else{
				replyTo cmdsync with cmdanswer : cmdanswer(ERROR)
			}
		}
	}
	Goto wait
}
QActor alarmreceivertest context ctxrobot{
	State wait initial {
		printCurrentMessage
		onMsg(alarm : alarm(_)){
			updateResource [# "alarmreceivertest(wait,alarm)" #] 
		}
		onMsg(alarmceased : alarmceased(_)){
			updateResource [# "alarmreceivertest(wait,alarmceased)" #] 
		}
	}
	Transition t0 whenEvent alarm -> wait
				  whenEvent alarmceased -> wait
}
