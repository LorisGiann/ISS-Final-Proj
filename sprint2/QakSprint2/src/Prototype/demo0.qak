//https://dl.bintray.com/jetbrains/kotlin/eclipse-plugin/0.8.19/
  
System demo0    
//mqttBroker "localhost" : 1883 eventTopic "demo0/events"
//mqttBroker "broker.hivemq.com" : 1883 eventTopic "demo0/events"
  
// ------------ wasteservice msgs --------------------
//MATERIAL = PLASTIC | GLASS
//TRUCKLOAD =  float number
Request depositrequest : depositrequest(MATERIAL, TRUCKLOAD)
Reply loadaccept     : loadaccept(MATERIAL, TRUCKLOAD)
Reply loadrejected     : loadrejected(MATERIAL, TRUCKLOAD)
// ------------------------------------------------------
   
// ------------ transporttrolley msgs -------------------
//RESULT =  OK | ERROR 
Request pickup         : pickup(_)
Reply   pickupanswer   : pickupanswer(RESULT)
Request dropout        : dropout(_)
Reply   dropoutanswer  : dropoutanswer(RESULT)
Request move           : move(POSITION)    //INDOOR | PLASTICBOX | GLASSBOX | HOME
Reply   moveanswer     : moveanswer(RESULT)
// ------------------------------------------------------

// ------------------ basicrobot msgs -------------------
//MOVE =  w | a | s | d | h    //w and s are asyncronous
Dispatch cmd       	: cmd(MOVE)     
Dispatch end       	: end(ARG)
 
Request step       : step( TIME )	
Reply   stepdone   : stepdone(V)  
Reply   stepfail   : stepfail(DURATION, CAUSE)
 
 
Event 	 moving 	   : moving (F,T)
Event    info          : info( ARG ) 	    //for external components, not coap-observed
Event    sonar         : sonar(DISTANCE,NAME)			//emitted by distancefilter
Dispatch obstacle      : obstacle( ARG ) 	//generated by distancefilter
// ------------------------------------------------------

//method to trigger the next transition within the state: send this message to the actor itself (cumbersome but works great)
Dispatch noMsg : noMsg(_)

//SONAR
Dispatch sonaractivate   : info(ARG)
Dispatch sonardeactivate : info(ARG)
Event    sonardistance   : distance( V )   //emitted by sonarSimulator or sonardatasource
Event    sonardata       : distance( V )   //for the application level	
Event    obstacle        : obstacle( D )   //for the application level

Dispatch enable			 : enable(_)
Dispatch disable		 : disable(_)

//LED 
Event    update_led 	 : update_led(ARG)
// ------------------ CONTEXTS -------------------
//REMEMBER TO PUT datacleaner AND distancefilter IN THE SAME CONTEXT OF basicrobot
Context ctxserver ip [host="localhost" port=8095]
Context ctxrobot ip  [host="127.0.0.1" port=8096]
Context ctxalarm ip  [host="127.0.0.1" port=8097]
// ------------------------------------------------

CodedQActor distancefilter context ctxserver className "rx.distanceFilter"   //Nel caso di robot virtuale semplicemente assorbe eventi obstacle e reinvia dispatch "obstacle:obstacle(virtual)" a basicrobot. Nel caso di robot reali riceve messaggi "sonarRobot" e invia a basicrobot dispatch "obstacle:obstacle(dist)" se vicino, altrimenti sonardata", "sonardata:distance(dist)" se lontano.
// ------------------------------------------------
// ------- basicrobot collision detection ---------
//DATA SOURCES
CodedQActor sonarsimulator  	   context ctxalarm className "sonarSimulator"  
CodedQActor sonarsimulatortesting  context ctxalarm className "sonarSimulatorTesting"  
CodedQActor sonardatasource 	   context ctxalarm className "sonarHCSR04Support2021"
CodedQActor datacleaner    		   context ctxalarm className "dataCleaner"



QActor wasteservice context ctxserver{  
	[# lateinit var Material  : ws.Material
	   var TruckLoad : Float = 0F
	   
	   lateinit var RES : String
	   lateinit var TrolleyPos : String   //gbox,pbox,Home,indoor
	#]
	
	State wait initial {
		updateResource [# "wasteservice(wait,${ws.func.contPB},${ws.func.contGB})" #] 
		printCurrentMessage
		discardMsg Off
		[# TrolleyPos = "home" #]
		println("Waiting for requests")
		//[# sysUtil.logMsgs=true #]
 	}
 	Transition t0 whenRequest depositrequest -> handle_req
 					whenReply moveanswer -> wait //consume pending moveanswer (happens when a request which has been rejected has been received while the robot was returning to home). See also test_1_accepted_1_rejected_while_returning_home_1_accepted() test
 	
 	State handle_req {
 		updateResource [# "wasteservice(handle_req,${ws.func.contPB},${ws.func.contGB})" #] 
		printCurrentMessage
		onMsg(depositrequest : depositrequest(MATERIAL, TRUCKLOAD)) {
			[#
				 Material 	= ws.Material.valueOf(payloadArg(0))
				 TruckLoad 	= payloadArg(1).toFloat()
			#]
			println("arrived $TruckLoad Kg of $Material")
			if[# ws.func.checkdepositpossible( Material, TruckLoad ) #]{
				[# ws.func.updateDeposit( Material, TruckLoad ) 
					#]
				println("PB capacity: ${ws.func.contPB}, GB capacity: ${ws.func.contGB}")	
				request transporttrolley -m move : move(INDOOR)
			} else{  
				replyTo depositrequest with loadrejected : loadrejected($Material,$TruckLoad)
				forward wasteservice -m noMsg : noMsg(_)
			}		
		} 
 	}
 	Transition t0 whenReply moveanswer -> handle_move_indoor
 				whenMsg noMsg -> wait
 	
 	State handle_move_indoor {
 		updateResource [# "wasteservice(handle_move_indoor,${ws.func.contPB},${ws.func.contGB})" #] 
		printCurrentMessage
		onMsg(moveanswer : moveanswer(RESULT)) {
			[# RES = payloadArg(0); #]
			if[# RES == "OK" #]{
				println("wateservice - request pickup")
				request transporttrolley -m pickup : pickup(_)
			}else{
				forward wasteservice -m noMsg : noMsg(_)
			}
		}
 	}
 	Transition t0 whenReply pickupanswer -> handle_pickup_answer
 					whenMsg noMsg -> error
 	
 	State handle_pickup_answer{
 		updateResource [# "wasteservice(handle_pickup_answer,${ws.func.contPB},${ws.func.contGB})" #] 
 		printCurrentMessage
 		onMsg(pickupanswer : pickupanswer(RESULT)) {
			[# RES = payloadArg(0); #]
			if[# RES == "OK" #]{ 
				[# 
					val Position = when(Material){
					    ws.Material.PLASTIC -> ws.Position.PLASTICBOX
					    ws.Material.GLASS -> ws.Position.GLASSBOX
					} #]
				println("move to ${Position}")
				request transporttrolley -m move : move($Position)
				replyTo depositrequest with loadaccept : loadaccept($Material,$TruckLoad)
			}else{
				forward wasteservice -m noMsg : noMsg(_)
			}
		}
 	}
 	Transition t0 whenReply moveanswer -> handle_move_container
 					whenMsg noMsg -> error
 					
 	State handle_move_container{
 		updateResource [# "wasteservice(handle_move_container,${ws.func.contPB},${ws.func.contGB})" #] 
 		printCurrentMessage
 		onMsg(moveanswer : moveanswer(RESULT)) {
			[# RES = payloadArg(0); #]
			if[# RES == "OK" #]{
				println("wateservice - request dropout ${Material}")
				request transporttrolley -m dropout : dropout(_)
			}else{
				forward wasteservice -m noMsg : noMsg(_)
			}
		}
 	}
 	Transition t0 whenReply dropoutanswer -> handle_dropout_answer
 					whenMsg noMsg -> error
 					
 	State handle_dropout_answer {
 		updateResource [# "wasteservice(handle_dropout_answer,${ws.func.contPB},${ws.func.contGB})" #] 
 		printCurrentMessage
 		onMsg(dropoutanswer : dropoutanswer(RESULT)) {
			[# RES = payloadArg(0); #]
			if[# RES != "OK" #]{
				forward wasteservice -m noMsg : noMsg(_)
			}
		}
 	} 
 	Transition t0 whenTime 10 -> move_home
 					whenMsg noMsg and [# RES!="OK" #] -> error
 					whenRequest depositrequest -> handle_new_req
 	
 	State handle_new_req{ //simile ad handle_request, ma qui dobbiamo fare andare il robot a casa in caso di loadReqjected
 		updateResource [# "wasteservice(handle_new_req,${ws.func.contPB},${ws.func.contGB})" #] 
		printCurrentMessage
		onMsg(depositrequest : depositrequest(MATERIAL, TRUCKLOAD)) {
			[#
				 Material 	= ws.Material.valueOf(payloadArg(0))
				 TruckLoad 	= payloadArg(1).toFloat()
			#]
			if[# ws.func.checkdepositpossible( Material, TruckLoad ) #]{
				[# ws.func.updateDeposit( Material, TruckLoad ) 
					#]
				println("PB capacity: ${ws.func.contPB}, GB capacity: ${ws.func.contGB}")	
				request transporttrolley -m move : move(INDOOR)
			} else{  
				replyTo depositrequest with loadrejected : loadrejected($Material,$TruckLoad)
				forward wasteservice -m noMsg : noMsg(_)
			}		
		}
 	}
 	Transition t0 whenReply moveanswer -> handle_move_indoor
 				whenMsg noMsg -> move_home
 	
 	State move_home{
 		updateResource [# "wasteservice(move_home,${ws.func.contPB},${ws.func.contGB})" #] 
 		printCurrentMessage
 		request transporttrolley -m move : move(HOME)
 	}
 	Goto handle_move_home
 	
 	State handle_move_home{
 		updateResource [# "wasteservice(handle_move_home,${ws.func.contPB},${ws.func.contGB})" #] 
 		printCurrentMessage
 		onMsg(moveanswer : moveanswer(RESULT)) {
			[# RES = payloadArg(0); #]
			if[# RES == "OK" #]{
				request transporttrolley -m dropout : dropout(_)
			}else{
				forward wasteservice -m noMsg : noMsg(_)
			}
		}
 	}
 	Transition t0 	whenRequest depositrequest -> handle_req //gestisci immediatamente nuova richiesta
 					whenMsg noMsg and [# RES!="OK" #] -> error
 					whenReply moveanswer -> wait
 	
 	State error {
 		updateResource [# "wasteservice(error,${ws.func.contPB},${ws.func.contGB})" #] 
 		println("error")
 		printCurrentMessage
 	}
}

QActor transporttrolley context ctxrobot{
	[# var dest = ws.Position.HOME
	   var currpos = ws.Position.HOME
	#]
	
	State init initial { 	    
		discardMsg On
		[# dest = ws.Position.HOME
	       currpos = ws.Position.HOME
		#]
		//println("Init trasport trolley")
		//[# sysUtil.logMsgs=true #]
 	}
 	Goto wait 
 	
 	State wait {
 		updateResource [# "transporttrolley(wait,$currpos,$dest)" #] 
 		println("transporttrolley | Wait (Dest: ${dest} CurrPos: ${currpos})")
 		[# val F = currpos 
		   val T = dest#]  
 		emit moving : moving ($F,$T)
 		if [# currpos!=dest #] {
 			forward transporttrolley -m noMsg : noMsg(_)
 		}
 	}
 	Transition toNewState whenRequest pickup and [# currpos==dest#]-> picking_up
 						  whenRequest dropout and [# currpos==dest#]-> dropping_down
 						  whenRequest move and [# currpos==dest#] -> set_new_dest
 						  whenMsg noMsg -> forward_robot
 						  whenMsg disable -> halt
 						  
	State halt{
		updateResource [# "transporttrolley(halt,$currpos,$dest)" #] 
		forward basicrobot -m cmd : cmd(h)
	}
	Transition toNewState whenMsg enable -> wait
	
	State forward_halt{
		updateResource [# "transporttrolley(forward_halt,$currpos,$dest)" #] 
		forward basicrobot -m cmd : cmd(h)
	}
	Transition toNewState whenMsg enable -> forward_robot
						  whenEvent info -> turn 
 						  
 	State picking_up {
 		updateResource [# "transporttrolley(picking_up,$currpos,$dest)" #] 
 		println("transporttrolley | PickUp material from truck")
 		delay 1000
		replyTo pickup with pickupanswer : pickupanswer(OK)
 	}
 	Goto wait
 	
 	State dropping_down {
 		updateResource [# "transporttrolley(dropping_down,$currpos,$dest)" #] 
 		println("transporttrolley | DropOut material in container")
 		delay 1000
		replyTo dropout with dropoutanswer : dropoutanswer(OK)
 	}
 	Goto wait
 	
 	State set_new_dest {
 		updateResource [# "transporttrolley(set_new_dest,$currpos,$dest)" #] 
 		onMsg( move:move(ARG) ){
			[# dest=ws.Position.valueOf(payloadArg(0)) #]
			[# val F = currpos 
			   val T = dest#]  
 			println("transporttrolley | New robot destination: ${dest}")
 			emit moving : moving ($F ,$T)
 		}
 	}
 	Goto wait
 	
 	State forward_robot {
 		updateResource [# "transporttrolley(forward_robot,$currpos,$dest)" #] 
 		//println("Forward robot")
 		forward basicrobot -m cmd : cmd(w)
 	}
 	Transition t1 whenEvent info -> turn
 				  whenMsg disable -> forward_halt
 	
 	State turn {
 		updateResource [# "transporttrolley(turn,$currpos,$dest)" #] 
 		[#currpos=ws.func.nextPosition(currpos) #]
 		forward basicrobot -m cmd : cmd(l)
 		delay 450
 		if [# currpos==dest #] {
 			println("transporttrolley | Robot arrived at $currpos")
			replyTo move with moveanswer : moveanswer(OK)
		}/*else{
			println("transporttrolley | moving (now in $currpos)")
		}*/
 	}
 	Goto wait
 	
}



QActor basicrobot context ctxrobot{
[#
  var StepTime      = 0L
  var StartTime     = 0L     
  var Duration      = 0L  
  var RobotType     = "" 
  var CurrentMove   = "unkknown"
#]  
 	State s0 initial { 	      
 		discardMsg Off  //WE want receive any msg
		println("basicrobot | START")	
 		qrun unibo.robot.robotSupport.create(myself,"basicrobotConfig.json")	
 		[# RobotType = unibo.robot.robotSupport.robotKind #]
 		/*delay 1000  //give to the realsonar the time to start
        if[# RobotType != "virtual" #]{
        	[# var robotsonar = context!!.hasActor("realsonar")  
        	   if(robotsonar != null) unibo.robot.robotSupport.createSonarPipe(robotsonar) 
        	#] 
  		}//The Virtual robot sonar is created in virtualrobotSupport2021*/
 
  		//run unibo.robot.robotSupport.move( "l" )    //synch
 		//run unibo.robot.robotSupport.move( "r" )	//synch
    		//run unibo.robot.robotSupport.move( "w" )    //asynch 
 		updateResource [# "basicrobot(start)" #]
 	} 
	Goto work
	
	State work{ 
		println("basicrobot | waiting .............. ")  
	} 
	Transition t1   whenMsg     cmd       -> execcmd
					whenRequest step      -> doStep			
					whenMsg    obstacle   -> handleObstacle  //in virtualrobot caused by the move w/s
					//whenEvent sonar       -> handleSonar
				  	whenMsg     end       -> endwork			  
	
	State execcmd{
		printCurrentMessage
		onMsg( cmd : cmd(MOVE) ){
  			//activate the motors
  			[# val Move = payloadArg(0) #]
  			println("basicrobot | executing '${Move}'")
			run unibo.robot.robotSupport.move( Move )
			updateResource [# "moveactivated(Move)" #]
		}
	 }
	 Goto work  
	 
	State handleObstacle{
		//println("basicrobot | handleObstacle")	
		run unibo.robot.robotSupport.move( "h" )
		delay 600
		//printCurrentMessage
		updateResource [# "obstacle(${CurrentMove})" #]
		/*if[# CurrentMove == "w"#]{
		//back to avoid emission of obstacle again if real robot moving forward !!!
		//if[# RobotType != "virtual" #]{	//is it better to embed this behavior in the support?
			run unibo.robot.robotSupport.move( "s" )
			delay 100 
			run unibo.robot.robotSupport.move( "h" ) 
 		}*/
 		emit info : info( obstacledoing(w) )
	}
	Goto work 
 
	/*State handleSonar{
		printCurrentMessage
	}
	Goto work*/
		
   	State doStep{ 
 		printCurrentMessage  
		onMsg( step : step( T ) ){  
			[#	StepTime = payloadArg(0).toLong() 	#]  
			updateResource [# "step(${StepTime})" #]
  		}  
        memoCurrentTime StartTime  
        println("basicrobot | doStep StepTime =$StepTime  ")        
        run unibo.robot.robotSupport.move( "w" )  //moves a real robot forever !!!
	}  
	Transition t0 
		whenTimeVar StepTime  -> stepDone  	 
 		whenMsg  obstacle     -> stepFail		
    	 
	
	State stepDone{   
 		run unibo.robot.robotSupport.move( "h" )  //stop the real robot already done ???
		updateResource [# "stepDone($StepTime)" #]
   		//emit info : info( stepdone($StepTime) )
   		replyTo step with stepdone : stepdone(ok)
		println("basicrobot | stepDone reply done")
  	}
	Goto work  
 
	State stepFail{  		
		setDuration Duration from StartTime
		run unibo.robot.robotSupport.move( "h" )  //stop the (real) robot
		[# var TunedDuration = Duration;  
			TunedDuration = Duration * 5 / 6
		#]
		println("basicrobot | stepFail duration=$Duration TunedDuration=$TunedDuration")
			run unibo.robot.robotSupport.move( "s" )
			delayVar TunedDuration 
			run unibo.robot.robotSupport.move( "h" ) 
 		updateResource [# "stepFail($Duration)" #] 
 		//emit info : info( stepFail($Duration) )
 		replyTo step with stepfail : stepfail($Duration, obst)
    }
	Goto work
	
	State endwork{ 
		updateResource [# "basicrobot(end)" #]	 		
 		terminate 1
	}   
 
}


QActor alarmcontrol context ctxalarm{
	[# var ISHOME: Boolean = true
	   val DLIMIT: Int = 10
	   var DISABLE: Boolean = false
	   		
	   fun checkIsHome(F: String, T: String) : Boolean {
	       return F==T;
	   }	   
	#]

	State init initial{
		printCurrentMessage
		println("Activate the sonar")
		updateResource [# "alarmcontrol(activateSonar)" #]	 
		forward sonar -m sonaractivate : info(ok)

	}
	Goto wait

	State wait{
		println("wait")
	}
	Transition t0 whenEvent moving -> handle_moving
				  whenEvent sonardata -> handle_distance 
				  
	State handle_moving{
		onMsg( moving : moving(F,T) ){
			[# val F = payloadArg(0)   #] 
			[# val T = payloadArg(1)   #]   
			[# ISHOME=checkIsHome(F,T) #]
			updateResource [# "alarmcontrol(handle_moving,${F},${T})" #]	 
			if [# ISHOME==true #]{
  		    	println("led off")
  		    	emit update_led : update_led(off)
  		    }else {
  		    	println("led blink")
  		    	emit update_led : update_led(blink)
  		    }
		}
	}
	Goto wait
	
	State handle_distance{
		onMsg( sonardata : distance(D) ){
   		 	[# val D = payloadArg(0).toInt() #]  
  		    //println("Distance ${D}")		    
  		    //LED
  		    if [# ISHOME==false && D<DLIMIT#]{
  		    	emit update_led : update_led(on)
  		    	println("led on")
  		    }
  		    if [# ISHOME==false && D>=DLIMIT#]{ 
  		    	println("led blink")
  		    	emit update_led : update_led(blink)
  		    }
  		    
  		    if [# D<DLIMIT#]{
  		    	updateResource [# "alarmcontrol(handle_distance,${D},${DLIMIT},true)" #]	 
  		    	updateResource [# "alarmcontrol(disable)" #]	
  		    	}
  		    else{
	  		    if [# D>=DLIMIT && DISABLE==true  #] {
	  		    	updateResource [# "alarmcontrol(handle_distance,${D},${DLIMIT},false)" #]	 
	  		    	updateResource [# "alarmcontrol(enable)" #]	 
	  		    }else{
	  		    	updateResource [# "alarmcontrol(handle_distance,${D},${DLIMIT},${DISABLE})" #]	
	  		    }
  		    }
  		    //TRASPORTROLLEY
  		    if [# D<DLIMIT#]{
  		    	[# DISABLE=true #]
  		    	forward transporttrolley -m disable : disable(_)
  		    }
  		    if [# D>=DLIMIT && DISABLE==true  #] {
  		    	[# DISABLE=false #]
  		    	forward transporttrolley -m enable : enable(_)
  		    }
  		    
  		 }
	}
	Goto wait
}

QActor sonar context ctxalarm {
	[# val simulate       = true
	   val sonarActorName = "sonar"
	   val usingDomain    = false
	#]
	State s0 initial {
		printCurrentMessage
		run  sonarConfig.configureTheSonar(simulate, sonarActorName, usingDomain)
		 
		//ASSUMPTION: the sonar subsystem emits the event sonar:distance(V)
	}
	Transition t0 whenMsg sonaractivate   -> activateTheSonar
			      whenMsg sonardeactivate -> deactivateTheSonar
	
	State activateTheSonar{
		printCurrentMessage
		println("activate the sonar")
		if[#  `it.unibo`.radarSystem22.domain.utils.DomainSystemConfig.simulation #]{
			println("sonar simulator")
			updateResource [# "sonaractivate" #]
			forward sonarsimulatortesting -m sonaractivate : info(ok) 
			//run sonarConfig.activateSonarSimulated() //usingDomain
		}else {
			println("sonar real")
			forward sonardatasource -m sonaractivate : info(ok)  
		}
	}
	Transition t0  whenEvent sonardistance         -> handleSonarData  
	               whenMsg   sonardeactivate       -> deactivateTheSonar
	
	State deactivateTheSonar{
		printCurrentMessage
	}
	Goto end
  
  	State handleSonarData{
  		 onMsg( sonar : distance(D) ){
   		 	[# val D = payloadArg(0) #]   
   		 	updateResource [# "Distance ${D}" #]
  		    println("Distance ${D}")
  		 	emit sonardata : distance($D) //for the application
  		 }
  	}
   	Transition t0 whenEvent sonardistance -> handleSonarData
   				  whenMsg   sonardeactivate -> deactivateTheSonar
   		
	State end{  
		println("sonarqak22 BYE")
		updateResource [# "sonardeactivate" #]
		[# System.exit(0) #]
	}
}

QActor led context ctxalarm{ 
	[# lateinit var ledM : `it.unibo`.radarSystem22.domain.interfaces.ILed
	   lateinit var newState : String #]
	
	State s0 initial { 	     
		discardMsg On
		printCurrentMessage
		updateResource [# "led(off)" #]
		println("${name} STARTS")
		[# ledM = `it.unibo`.radarSystem22.domain.models.LedModel.create() #]
		//[# sysUtil.logMsgs=true #]
 	}
 	Transition t0 whenEvent update_led -> handle_update
 	
 	State handle_update { 
		onMsg( update_led:update_led(ARG) ){
			[# newState = payloadArg(0) #]
 			println("update_led(${newState})")
 			forward led -m noMsg : noMsg(_)
 		}
 	}
 	//Transition to else Goto off
 	Transition toNewState whenMsg noMsg and [# newState=="off" #] -> off
 						  whenMsg noMsg and [# newState=="on" #] -> on
 						  whenMsg noMsg and [# newState=="blink" #] -> blink_on
 	
 	State off {
 		updateResource [# "led(off)" #]
 		println("Led off")
 		[# unibo.actor22comm.utils.ColorsOut.outappl("${name} - off", unibo.actor22comm.utils.ColorsOut.GREEN)#]
 		[# ledM.turnOff()#]
 	}
 	Transition t0 whenEvent update_led -> handle_update
 	
 	State on {
 		updateResource [# "led(on)" #]
 		[# unibo.actor22comm.utils.ColorsOut.outappl("${name} - on", unibo.actor22comm.utils.ColorsOut.GREEN)#]
 		println("Led on")
 		[# ledM.turnOn()#]
 	}
 	Transition t0 whenEvent update_led -> handle_update
 	
 	State blink_on {
 		updateResource [# "led(blink)" #]
 		[# unibo.actor22comm.utils.ColorsOut.outappl("${name} - on", unibo.actor22comm.utils.ColorsOut.GREEN)#]
 		println("Blinking on")
 		[# ledM.turnOn()#]
 	}
 	Transition t0 whenTime 500 -> blink_off
 					whenEvent update_led -> handle_update
 					
 	State blink_off {
 		updateResource [# "led(blink)" #]
 		[# unibo.actor22comm.utils.ColorsOut.outappl("${name} - off", unibo.actor22comm.utils.ColorsOut.GREEN)#]
 		println("Blinking off")
 		[# ledM.turnOff()#]
 	}
 	Transition t0 whenTime 500 -> blink_on
 					whenEvent update_led -> handle_update
}



//wasteservice TESTER
//TEST VETRO RIGETTATO E PLASTICA ACCETTATA, RICHIESTE SEQUENZIALE
/*
QActor testwasteservice context ctxserver{
	State s0 initial { 	    
		discardMsg On
		//[# sysUtil.logMsgs=true #]
		request wasteservice -m depositrequest : depositrequest(GLASS,11)
 	}
 	Transition t0 whenReply loadaccept -> error
 					whenReply loadrejected -> s1
 	
 	State s1 {
 		println("load rejected successfully")
 		request wasteservice -m depositrequest : depositrequest(PLASTIC,3)
 	}
 	Transition t0 whenReply loadaccept -> s2
 					whenReply loadrejected -> error
 	
 	State s2 {
 		println("load accepted successfully")
 	}
 	
 	State error {
 		println("errore")
 	}
} 
 
//TEST PLASTICA ACCETTATA, PLASTICA RIGETTATA, SEQUENZIALI
/*QActor testwasteservice context ctxRPI{
	State s0 initial { 	    
		discardMsg On
		//[# sysUtil.logMsgs=true #]
		request wasteservice -m depositrequest : depositrequest(PLASTIC,9)
 	}
 	Transition t0 whenReply loadaccept -> s1
 					whenReply loadrejected -> error
 	
 	State s1 {
 		println("load accepted successfully")
 		request wasteservice -m depositrequest : depositrequest(PLASTIC,2)
 	}
 	Transition t0 whenReply loadaccept -> error
 					whenReply loadrejected -> s2
 	
 	State s2 {
 		println("load rejected successfully")
 	}
 	
 	State error {
 		println("errore")
 	}
}*/

