<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
    <!--
<link rel="stylesheet" type="text/css" href="../css/issStyle1.css">
<script type="text/javascript" src="../css/issStyle.js"></script>
-->
<link rel="stylesheet" type="text/css" href="../docs_common/defaultTemplateStyle.css">
<style>
code>pre { 
    font-family: monospace;
}
dd{
    margin-bottom: 7px;
}
.todo{
    color: orange
}
.centerimg{
    display: block;
    padding-top: 8px;
    padding-bottom: 8px;
    margin-left: auto;
    margin-right: auto;
    width: 90%;
    max-width: 800px;
}
p { margin: 4px 0px; }
dd{ margin-bottom: 8px;}
</style>
<head>
   
<title>WasteService SPRINT2</title></head>
    
<body>
<div id="top">
<h1>ISS FINAL PROJECT </h1>
</div>  

<div class="body"> 
<h2>Introduction</h2>
<div class="remark">
    <p>Progetto finale di ISS, che consiste in un impianto di smistamento dei rifiuti nel quale un robot deve trasportare il materiale dal camion al relativo container</p>
</div>

<h2>Requirements</h2>
<div class="remark">
    <a href="../docs_prof/html/TemaFinale22.html">Link alla pagina dei requisiti del committente</a>
    <br><br>
    <a href="../sprint1/sprint1.html">Link alla pagina dello SPRINT1</a>
    <br><br>
    <p>Ulteriori requisiti scaturiti da colloqui con committente:</p>
    <ul>
        <lI>Può esserci solo un camion alla volta in INDOOR? SI</lI>
        <li>Il Waste-truck deve essere liberato non appena il materiale viene scaricato? SI</li>
        <li>La GUI deve mostrare le coordine del robot o basta l'area nella quale si trova attualmente? basta l'area nella quale si trova attualmente</li>
        <li>A cosa serve il sonar se la stanza è priva di ostacoli? Il sonar non è a bordo del robot, è un dispositivo esterno (così come il RPI). Se si mette una mano davanti al dispositivo, il robot si ferma.</li>
        <li>Ci deve essere il contatto con la parete per il carico/scarico dei materiali? SI (o comunque il più vicino possibile)</li>
        <li>Supponiamo che il robot si stia dirigendo verso HOME (perché ha scaricato l'ultimo carico di materiale e non ci sono altri Waste truck sull'INDOOR). Se arriva un Waste truck prima che il trolley raggiunga la base, il robot deve cambiare rotta immediatamente o può raggiungere la base e poi dirigersi presso l'Indoor? CAMBIA IMMEDIATAMENTE ROTTA per dirigersi su indoor</li>
        <li>È il robot a determinare quando avviene la fine di una azione di carico/scarico? In che modo tale evento può essere rilevato dal sistema da noi sviluppato? Modellare l'operazione con un SEMPLICE DELAY di durata fissa</li>
        <li>Il nodo sul quale la GUI va installata e un nodo fisso? O si tratta forse di palmari posseduti dai Service-manager stessi? Il NODO è FISSO </li>
        <li>In cosa consiste lo smart device? Quanti sono (viene usato sempre lo stesso dispositivo o ve ne è uno per ogni conducente)? Come si relaziona con il nostro sistema? Un dispositivo per ogni conducente, "alieno" invia un messaggio</li>
        <li>Committente ha server aziendali disponibili? È possibile usare la RPI come server (nodo sempre attivo mentre il sistema è operativo)? E' possibile usare la raspberry, ma si può anche mettere sul PC che usiamo.</li>
    </ul>
</div>

<h2>Scrum Goal and Work Plan</h2>
<div class="remark">
    <dt><a href="../sprint1/sprint1.html#ScrumGoalWorkPlan">Link allo scrum goal e work plan dello SPRINT1</a></dt>
    <br><br>
    <p><b>Scrum goal</b>: obiettivo dello <u>SPRINT2</u>  è la creazione di una seconda demo (su ambiente virtuale) che, partendo dalla demo sviluppata tramite lo SPRINT1, implementi i <i>warning devices</i> e gli <i>alarm devices</i> (l'entità <b>led</b> e l'entità <b>sonar)</b>.</p>
    <p><b>Piano di lavoro:</b></p>
    <ul>
        <li>Comprensione dei requisiti del sistema relativi al <i>led</i> e al <i>sonar</i></li>
        <li>Analisi delle principali problematiche da affrontare nello sviluppo dei componenti analizzati di cui è composto il sistema</li>
        <li>Definire i componenti e le interazioni fra di essi: realizzazione di una seconda architettura logica partendo da quella definita all'interno dello SPRINT1</li>
        <li>Realizzazione di modelli usando un linguaggio di modellazione che permetta di formalizzare e di creare modelli eseguibili facendo uso del metamodello <a href="../Qak.html">QAK</a>.</li>
        <li>Realizzazione di test-plan</li>
    </ul>

</div>

<h2>Requirement analysis</h2>

<h3>Dizionario</h3>
<div class="remark">
    <dl>
        <dt><a href="../sprint1/sprint1.html#Dizionario">Link al dizionario dello SPRINT1</a></dt>
        <br><br>
        <dt><b>LED concreto:</b></dt> 
        <dd>Dispositivo di output connesso al RaspberryPI (che NON è a bordo del <b>DDR Robot</b>)</dd>
        <dt><b>LED:</b></dt>
        <dd><i>Warning device</i> corrispondente ad una entità attiva e astratta che rappresenta il <b>LED concreto:</b>, è che può essere impostato secondo 3 modalità:
            <ul>
                <lI>Led Off: quando il <b>Transport trolley</b> è in <b>HOME</b> </lI>
                <lI>Led On: quando il <b>Transport trolley</b> è fermo (quando distanza rilevata &lt DLIMIT)</lI>
                <lI>Led Blink: quando il <b>Transport trolley</b> è in movimento, o sta scaricando/caricando materiale</lI>
            </ul>
            <p>Il committente fornisce già del software per relativo al led in <a href="https://github.com/anatali/issLab2022/tree/main/it.unibo.radarSystem22.domain">it.unibo.radarSystem22.domain</a></p>
            <br>
            <p>Con il file <a href="./RequirementQakSprint2/src/requirementAnalysis/ledRequirement.qak">ledRequirement.qak</a> abbiamo potuto formalizzare interfaccia e comportamento di questo componente. <br>
            Inoltre, al fine di meglio specificare il comportamento che ci si aspetta, sono stati predisposti alcuni semplici test in <a href="./RequirementQakSprint2/test/testSprint2/TestLed.kt">TestLed.kt</a></p>
        </dd>
        <dt><b>Sonar concreto:</b></dt> 
        <dd>Dispositivo di input connesso al RaspberryPI (che NON è a bordo del <b>DDR Robot</b>)</dd>
        <dt><b>Sonar:</b></dt> 
        <dd><i>Alarm device</i> corrispondente ad una entità che rappresenta il <b>sonar concreto</b>. <br>
            <p>Il committente fornisce già del software relativo al sonar in <a href="https://github.com/anatali/issLab2022/tree/main/unibo.basicrobot22">unibo.basicrobot22</a>, <a href="https://github.com/anatali/issLab2022/tree/main/it.unibo.radarSystem22.domain">it.unibo.radarSystem22.domain</a>, <a href="https://github.com/anatali/issLab2022/tree/main/unibo.sonarqak22">unibo.sonarqak22</a></p>
            <p>Formalizziamo il sonar con un attore QAK. In particolare nel progetto <a href="https://github.com/anatali/issLab2022/tree/main/unibo.sonarqak22">unibo.sonarqak22</a> esiste un attore <i>sonarqak22</i> in grado di emettere eventi in base alla distanza rilevata da sonar reale o simulato: </p>
            <code><pre>
                Dispatch sonaractivate   : info(ARG)
                Dispatch sonardeactivate : info(ARG)
                Event    sonar           : distance( V )   //emitted by sonarSimulator or sonardatasource</pre>
            </code>
            <p>I comandi <i>sonaractivate</i> e <i>sonardeactivate</i> servono rispettivamente per attivare e disattivare il sonar, mentre l'evento <i>sonar</i> viene emesso o da <i>sonarsimulator</i>, o da <i>sonardatasource</i> e inviato al prossimo attore della pipe. La pipe può essere configurata nel seguente modo:</p>
            <code><pre>
                if( simulate )  firstActorInPipe = sysUtil.getActor("sonarsimulator")!!  //generates simulated data
                else firstActorInPipe           = sysUtil.getActor("sonardatasource")!!  //generates REAL data
                firstActorInPipe.
                    subscribeLocalActor("datacleaner"). 		//removes 'wrong' data''
                    //subscribeLocalActor("datalogger").		    //logs (shows) the data generated by the sonar
                    //subscribeLocalActor("sonar").				//handles sonarrobot but does not propagate ...
                    //subscribeLocalActor("distancefilter").		//propagates the lcoal stream event obstacle
                    subscribeLocalActor(sonarActorName)</pre>
            </code>
            <p>In particolare l'attore <i>distancefilter</i> si occupa di filtrare gli eventi e inviare al prossimo attore solo eventi di tipo obstacle:obstacle($distance) solo nel caso in cui la distanza rilevata sia minore di una distanza prefissata.</p>
            <img src="../docs_prof/html/_images/sonarpipenano.png" class="centerimg" style="max-width: 800px;"/>
        </dd>
        <dt><b>DLIMT:</b></dt>
        <dd>Misura in CM della distanza limite. Se la distanza attualmente misurata dal <b>Sonar concreto</b> è ≤ DLIMT, il robot deve essere nello stato stopped. Qunando la distanza misurata &gt DLIMIT il robot può muoversi<br>
            Viene formalizzato tramite una costante <b>DLIMIT</b>.<br>
            <code><pre>val DLIMIT : Float</pre></code></dd>
    </dl>
</div>

<!--PROBLEM ANALYSIS-->
<h2>Problem analysis</h2>
<div class="remark">
    <dt><a href="../sprint1/sprint1.html#ProblemAnalysis">Link alla problem analysis dello SPRINT1</a></dt>
    <br><br>

    <h3><b>Interazione robot - sonar</b></h3>

    <p>Sono state analizzate diverse possibilità per integrare in maniera coerente la possibilità di fermare e far riprendere le attività che il robot deve svolgere. <br>
        A tal fine supponiamo di ricevere già eventi del tipo <i>stop</i> e <i>resume</i> (che sarà generato da qualche attore a sua volta collegato al sonar "di base")</p>

    <h4>OPZIONE 1</h4>
    <p><b>Transport trolley</b> riceve direttamente gli eventi <i>stop</i> e <i>resume</i>, inviando gli opportuni comandi di basso livello a <i>basicrobot</i>:</p>
    <img src="../sprint2/docs/_images/transporttrolley_option1_logic_architecture.png" class="centerimg" style="max-width: 250px;"/>
    <ul>
        <li>- <b>Transport trolley</b> ha la responsabilità diretta di restare in ascolto di eventi riguardanti il sonar</li>
    </ul>
    <p>La macchina a stati dell'attore <i>transporttrolley</i> non risulta ancora eccessivamente complicata (rispetto a prima è stato aggiunto solo lo stato <i>halt</i>):</p>
    <img src="../sprint2/docs/_images/transporttrolley_option1_state_machine.png" class="centerimg" style="max-width: 500px;"/>
    <p style="font-size: 0.8rem;">N.B: per maggior robustezza è stata inserita la transizione da halt a turn nell'eventualità che il robot riesca comunque a raggiungere il muro subito 
        dopo aver impartito il comando di halt (dovuto a inerzia del robot, ritardo nell'arrivo dell'evento <i>info</i>, ecc..).</p>
    
    <h4>OPZIONE 2 e 3</h4>
    <p>Le opzioni 2 e 3 sono simili, in quanto prevedono entrambe l'utilizzo di un attore intermedio (qui chiamato <i>intermediario</i>) il cui compito è quello di ricevere i comandi inviati 
        da <i>transporttrolley</i>, e di mandarli al sottostante <i>basicrobot</i> compatibilmente con i comandi di <i>stop</i> e <i>resume</i>. Più nello specifico, dovrà fermare il robot quando 
        viene ricevuto il comando di <i>stop</i>, metnre se viene ricevuto <i>resume</i> il robot verrà fatto ripartire solo se era precedentemente in movimento.</p>
        <img src="../sprint2/docs/_images/transporttrolley_option3_logic_architecture.png" class="centerimg" style="max-width: 300px;"/>
        <ul>
            <li>+ principio di singola resposabilità: Il transporttrolley traduce le destinazioni da raggiungere in comandi di basso livello, senza preoccuparsi di rimanere in ascolto di eventi dal sonar</li>
        </ul>
        <table style="width:100%; text-align: start;">
            <tr style="border: 1px solid black;">
                <td>
                    <p>L'opzione 2 raggiunge questo obiettivo rendendo i comandi da inviare al <i>basicrobot</i> sincroni: la risposta non verrà data finche il robot risulta bloccato dal sonar 
                        non verrà data la risposta a <b>Transport trolley</b>, il quale quindi non potrà procedere con le prossime mosse.</p>
                    <ul>
                        <li>- richiede di modificare il transport trolley</li>
                    </ul>
                </td>
                <td style="width:25%; min-width: 310px;"><img src="../sprint2/docs/_images/transporttrolley_option2_state_machine.png" class="centerimg" style="width: 300px;"/></td>
            </tr>
            <tr style="border: 1px solid black;"> 
                <td>
                    <p>L'opzione 3 permette di ottenere lo stesso risultato utilizzando gli stessi comandi di tipo dispatch attualmente inviati dal <b>Transport trolley</b>. 
                        Quest'ultimo saprà comunque quando l'operazione <i>cmd(w)</i> termina siccome resta in ascolto dell'evento <i>info</i>.
                        </p>
                    <ul>
                        <li>+ Richiede solo di modificare il destinatario dei messaggi del transporttrolley.</li>
                    </ul>
                </td>
                <td style="width:25%; min-width: 310px;"><img src="../sprint2/docs/_images/transporttrolley_option3_state_machine.png" class="centerimg" style="max-width: 300px;"/></td>
            </tr>
        </table>
        <p>Le opzioni 2 e 3 sono ottime se il robot si deve fermare solo mentre questo sta procedendo in avanti. <br>
            Sarebbe però opportuno fermare il robot anche tra un'operazione e l'altra, quindi non solo mentre si sta spostando in avanti. Ad esempio, supponiamo che il robot sia arrivato in indoor 
            ed abbia appena iniziato a girarsi (stato TURN di <i>transporttrolley</i>). Se in questo momento la distanza diventa &ltDLIMIT, il robot si dovrebbe fermare subito dopo aver completato 
            l'operazione di turn, ossia deve aspettare prima di eseguire una <b>Pickup</b>. Ma <b>Pickup</b> è un'operazione svolta da <i>transporttrolley</i>, quindi non può essere facilmente 
            controllata dall'intermediario.
            Inoltre, supponendo che la distanza diventi &ltDLIMIT durante una operazione di <b>Pickup</b>, il basicrobot riceverà dapprima un comando <i>cmd(w)</i>, e poi un <i>cmd(h)</i>, provocando dunque un glitch. 
        </p>

        <h4>OPZIONE 4 (= soluzione adottata)</h4>
        <p>Optiamo quindi per una 4a opzione, che è per certi versi simile alla 1a, ma con la differenza che ora il transporttrolley espone un'ulteriore operazione che consentono al robot di 
            essere "abilitato" o "disabilitato" a comando. <br>            
            Tali operazioni assumono un significato particolare nel caso in cui il robot si stia muovendo in avanti: in tal caso il robot viene fermato, mentre la riabilitazione provoca il ripristino 
            dell'avanzamento. Questo non accade per tutte le altre mosse, che vengono infatti portate sempre a termine (siccome più rapide), tuttavia subito dopo la loro esecuzione si aspetta il 
            messaggio di riabilitazione prima di eseguire altre mosse.</p>
        <img src="../sprint2/docs/_images/transporttrolley_option4_state_machine.png" class="centerimg" style="max-width: 700px;"/>
        <p>L'invio di questi comandi è delegato ad un apposito controllore <i>alarmcontrol</i>, la cui responsabilità è proprio quella di controllare le azioni da svolgere nel caso in cui la distanza 
            rilevata dal sonar varchi la soglia DLIMIT. L'architettura logica diventa dunque la seguente:
        </p>
        <img src="../sprint2/docs/_images/transporttrolley_option4_logic_architecture.png" class="centerimg"/>
        <p style="font-size: 0.8rem;">N.B: per limitazioni imposti dal linguaggio QAK, inviamo i comandi <i>enable</i> e <i>disable</i> sottoforma di dispatch, siccome gli eventi non vengono accodati dagli attori.</p>
    
    <h3><b>Led</b></h3>
    <p>Per il led seguiamo la stessa linea di ragionamento intrapresa per il sonar, ossia l'utlizzo dell'attore <i>alarmcontrol</i> per coordinare le azioni derivanti dalla variazione della
        distanza misurata dal sonar. Esso comanderà anche il cambiamento di stato del led.<br>
        Per farlo il controllore ha tuttavia necessità di sapere se dove sia il robot attualmente, più in particolare è necessario sapere se esso è al di fuori di <b>HOME</b> o meno. Il reperimento
        di tale informazione è possibile grazie all'emissione di eventi di tipo <i>moving(From,To)</i> da parte del <i>transporttrolley</i>: il robot si trova in <b>HOME</b> se e solo se 
        <i>From</i>=<i>To</i>=<b>HOME</b>. </p>
    <img src="../sprint2/docs/_images/logic_architecture.png" class="centerimg"/>

    <h3>Attore-controller <i>alarmcontrol</i>:</h3>
    <p>La logica di questo attore viene qui descritta schematicametne in linguaggio naturale / pseudocodice.</p>
    <p>La parte del controller che si occupa di gestire il robot risulta piuttosto semplice, si tratta semplicemente di inviare a <i>transporttrolley</i> dei messaggi <i>enable</i> o <i>disable</i> 
        in base alla sola distanza rilevata:</p>
    <p class="pseudocode_i">
        <p>Ricezione evento <i>Distance(V)</i>:</p>
        <ul>
            <li>Se <code>V&ltDLIMIT</code> ➔ Transporttrolley DISABLE</li>
            <li>Se <code>V&gtDLIMIT</code> ➔ Transporttrolley ENABLE</li>
        </ul>
    </p>
    <p class="pseudocode_i">
        GESIONE <i>led</i>:
        <ul>
            <li>Ricezione evento <i>Moving(F,T)</i>:<br>
                si determina <code>ISHOME = (F==HOME && T==HOME)</code>
                <ul>
                    <li>Se <code>ISHOME==TRUE</code> ➔ led OFF</li>
                    <li>Se <code>ISHOME==FALSE</code> ➔ led BLINK</li>
                </ul>
            </li>
            <li>Ricezione evento <i>Distance(V)</i>:<br>
                <ul>
                    <li>Se <code>ISHOME==FALSE && V&ltDLIMIT</code> ➔ led ON</li>
                    <li>Se <code>ISHOME==FALSE && V&gtDLIMIT</code> ➔ led BLINK</li>
                </ul>
            </li>
        </ul>
    </p>
    <p>Il modello QAK dell'attore consiste semplicemente nei 2 stati di gesione dei due eventi, più quello iniziale di attesa:</p>
    <img src="../sprint2/docs/_images/alarmcontrol_state_machine.png" class="centerimg" style="max-width: 400px;"/>
    <p class="todo">Momento ottimo per riportare il QAK di questo <i>alarmcontrol</i>.</p>
</div>
    


<!--<h2>Project</h2> 
</div>-->


<h2>Test plans</h2> 
<div class="remark">

</div>

<h3><a href="QakSprint1/src/Prototype/demo0.qak">Metamodello eseguibile QAK</a></h3>
 
<!-- USEFUL
<table style="width:100%" border="1">
<tr>
<td style="width:50%">
</td>
<td></td>
</tr>
</table>
-->
	      	
<br/><br/> 	
</div>  

<div style="background-color:rgba(86, 56, 253, 0.9); width:100%;text-align:left;color:white">
    <table style="border: 0px solid transparent; margin: 0 auto;">
        <tr>
            <td>
                <p style="font-weight: bold;">Loris Giannatempo <br>
                Email: loris.giannatempo@studio.unibo.it</p>
                <img class="centerimg" src="../docs_common/lorisgiannatempo.jpg" style="width: 30%; height: 30%; border: 0px">
            </td>
            <td>
                <p style="font-weight: bold;">Davide Guidetti <br>
                Email: davide.guidetti3@studio.unibo.it</p>
                <img class="centerimg" src="../docs_common/davideguidetti.jpg" style="width: 30%; height: 30%; border: 0px">
            </td>
        </tr>
    </table>
</div> 
</body>
</html>