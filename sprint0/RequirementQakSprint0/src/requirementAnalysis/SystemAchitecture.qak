//https://dl.bintray.com/jetbrains/kotlin/eclipse-plugin/0.8.19/

System demosystemarchitecture
// --------------- wasteservice msgs --------------------
//MATERIAL = PLASTIC | GLASS
//TRUCKLOAD =  float number
Request depositrequest : depositrequest(MATERIAL, TRUCKLOAD)
Reply loadaccept     : loadaccept(MATERIAL, TRUCKLOAD)
Reply loadrejected     : loadrejected(MATERIAL, TRUCKLOAD)
// ------------------------------------------------------ 

// ------------------ basicrobot msgs -------------------
//MOVE =  w | a | s | d | h    | l | r   //w and s: the robot continues to go until an obstacle is found
Dispatch cmd       	: cmd(MOVE)
Dispatch end       	: end(ARG)
 
Request step       : step( TIME )	
Reply   stepdone   : stepdone(V)  
Reply   stepfail   : stepfail(DURATION, CAUSE)

Event    info          : info( ARG ) 	    //for external components, not coap-observed
Event    sonar         : sonar(DISTANCE,NAME)	//emitted by distancefilter
Dispatch obstacle      : obstacle( ARG ) 	//generated by distancefilter
// ------------------------------------------------------

//-------------------------------------- LED --------------------------------------------
Event    update_led 	  : update_led(LEDSTATE) // LEDSTATE = ON | OFF | BLINK
// ---------------------------------------------------------------------------------------

// ------------------------------------ OTHER GUI -------------------------------------
Event    update_tt_state  : update_tt_state(TTSTATE) // TTSTATE = IDLE | MOVING | PICKINGUP | DROPPINGDOWN | HALT
Event    update_position  : update_position(POSITION) //POSITION = INDOOR, PLASTICBOX, GLASSBOX, HOME
Event    update_container : update_container(PLASTIC,GLASS) // PLASTIC & GLASS float numbers (respectively ${ws.func.contPB},${ws.func.contGB})")
// ------------------------------------------------------------------------------------

//-------------------------------------- SONAR -------------------------------------
Dispatch sonaractivate   : info(ARG)
Dispatch sonardeactivate : info(ARG)
Event    sonardistance   : distance( V )   //emitted by sonarSimulator or sonardatasource
Event    sonardata       : distance( V )   //for the application level	
Event    obstacle        : obstacle( D )   //for the application level
//----------------------------------------------------------------------------------

// ---------------------------------- transporttrolley commands (to be defined in next sprints) ---------------------------
Request transporttrolleycmd  : transporttrolleycmd(CMD)
// ------------------------------------------------------------------------------------------------------------------------
    
// ---------------------- CONTEXTS -----------------------
Context ctxdriver ip [host="localhost" port=8094]
Context ctxserver ip [host="localhost" port=8095]
Context ctxrobot ip [host="localhost" port=8096]
Context ctxalarm ip [host="localhost" port=8097]
// ------------------------------------------------------

QActor smartdevice context ctxdriver{
	
	State s0 initial {
		request wasteservice -m depositrequest:depositrequest(_)
	}
}


QActor wasteservice context ctxserver{  
	[# var Material  : ws.Material
	   var TruckLoad : Float       #]
	
	State wait initial {
		printCurrentMessage
		discardMsg Off
	}
	Transition t0 whenRequest depositrequest -> handle_req
	
	State handle_req {
		printCurrentMessage
		onMsg(depositrequest : depositrequest(MATERIAL, TRUCKLOAD)) {
			[#   Material 	= ws.Material.valueOf(payloadArg(0))
				 TruckLoad 	= payloadArg(1).toFloat()   #]
			if[# ws.func.checkdepositpossible( Material, TruckLoad ) #]{
				[# ws.func.updateDeposit( Material, TruckLoad ) #]
				replyTo depositrequest with loadaccept : loadaccept($Material,$TruckLoad)
				
				//send commands towards transporttrolley
				request transporttrolley -m transporttrolleycmd : transporttrolleycmd(_)
				//update containers
				[# val Plastic = ws.func.contPB
					val Glass = ws.func.contGB #]
				emit update_container : update_container($Plastic, $Glass)
				
			}else{
				replyTo depositrequest with loadrejected : loadrejected($Material,$TruckLoad)
			}
		}
	}
	Goto wait
}

QActor transporttrolley context ctxrobot{
	
	State wait initial {
		printCurrentMessage
		discardMsg Off
 	}
 	Transition t0 whenRequest transporttrolleycmd -> handle_req
 	
 	State handle_req {
		printCurrentMessage
		onMsg(transporttrolleycmd : transporttrolleycmd(CMD)) {
				
				//send commands towards transporttrolley
				request basicrobot -m step : step(_)
				forward basicrobot -m cmd : cmd(_)
				
				//also send informations to the gui
				emit update_tt_state : update_tt_state(_)
				emit update_position : update_position(_)
				
		} 
 	}
 	Goto handling_req
 	
 	State handling_req {
		
 	}
 	Transition t0 whenEvent obstacle -> handle_obstacle
 					whenEvent info -> wait
 	
 	State handle_obstacle {
 		
 	}
 	Goto handle_req
}









QActor basicrobot context ctxrobot{
[#
  var StepTime      = 0L
  var StartTime     = 0L     
  var Duration      = 0L
  var ExpectingCollision = false
  //var RobotType     = "" 
  var CurrentMove   = "unkknown"
#]  
 	State s0 initial { 	      
 		discardMsg Off  //WE want receive any msg
		println("basicrobot | START")	
 		qrun unibo.robot.robotSupport.create(myself,"basicrobotConfig.json")	
 		//[# RobotType = unibo.robot.robotSupport.robotKind #]
 		/*delay 1000  //give to the realsonar the time to start
        if[# RobotType != "virtual" #]{
        	[# var robotsonar = context!!.hasActor("realsonar")  
        	   if(robotsonar != null) unibo.robot.robotSupport.createSonarPipe(robotsonar) 
        	#] 
  		}//The Virtual robot sonar is created in virtualrobotSupport2021*/
 
  		//run unibo.robot.robotSupport.move( "l" )    //synch
 		//run unibo.robot.robotSupport.move( "r" )	//synch
    		//run unibo.robot.robotSupport.move( "w" )    //asynch 
 		updateResource [# "basicrobot(s0)" #]
 	}
	Goto work

	State work{
		println("basicrobot | waiting .............. ")
	}
	Transition t1   whenMsg     cmd       -> execcmd
					whenRequest step      -> doStep
					whenMsg    obstacle   -> handleObstacle  //in virtualrobot caused by the move w/s
					//whenEvent sonar       -> handleSonar
				  	whenMsg     end       -> endwork

	State execcmd{
		printCurrentMessage
		onMsg( cmd : cmd(MOVE) ){
  			//activate the motors
  			[# val Move = payloadArg(0) #]
  			[# if(Move=="w") ExpectingCollision=true #]
  			println("basicrobot | executing '${Move}'")
			run unibo.robot.robotSupport.move( Move )
			updateResource [# "basicrobot(execcmd,$Move)" #]
		}
	 }
	 Goto work

	State handleObstacle{
		printCurrentMessage
		//println("basicrobot | handleObstacle")
		if[# ExpectingCollision #]{
			[# ExpectingCollision=false #]
			run unibo.robot.robotSupport.move( "h" )
			delay 600
			updateResource [# "basicrobot(handleObstacle,${CurrentMove})" #]
			/*if[# CurrentMove == "w"#]{
			//back to avoid emission of obstacle again if real robot moving forward !!!
			//if[# RobotType != "virtual" #]{	//is it better to embed this behavior in the support?
				run unibo.robot.robotSupport.move( "s" )
				delay 100
				run unibo.robot.robotSupport.move( "h" )
	 		}*/
	 		emit info : info( obstacledoing(w) )
	 		//forward transporttrolley -m wall : wall( obstacledoing(w) )
		}
	}
	Goto work

	/*State handleSonar{
		printCurrentMessage
	}
	Goto work*/

   	State doStep{
 		printCurrentMessage
		onMsg( step : step( T ) ){
			[#	StepTime = payloadArg(0).toLong() 	#]
			updateResource [# "basicrobot(doStep,${StepTime})" #]
  		}
        memoCurrentTime StartTime
        println("basicrobot | doStep StepTime =$StepTime  ")
        run unibo.robot.robotSupport.move( "w" )  //moves a real robot forever !!!
	}
	Transition t0
		whenTimeVar StepTime  -> stepDone
 		whenMsg  obstacle     -> stepFail


	State stepDone{
 		run unibo.robot.robotSupport.move( "h" )  //stop the real robot already done ???
		updateResource [# "basicrobot(stepDone,$StepTime)" #]
   		//emit info : info( stepdone($StepTime) )
   		replyTo step with stepdone : stepdone(ok)
		println("basicrobot | stepDone reply done")
  	}
	Goto work

	State stepFail{
		setDuration Duration from StartTime
		run unibo.robot.robotSupport.move( "h" )  //stop the (real) robot
		[# var TunedDuration = Duration;
			TunedDuration = Duration * 5 / 6
		#]
		println("basicrobot | stepFail duration=$Duration TunedDuration=$TunedDuration")
			run unibo.robot.robotSupport.move( "s" )
			delayVar TunedDuration
			run unibo.robot.robotSupport.move( "h" )
 		updateResource [# "basicrobot(stepFail,$Duration)" #]
 		//emit info : info( stepFail($Duration) )
 		replyTo step with stepfail : stepfail($Duration, obst)
    }
	Goto work

	State endwork{
		updateResource [# "basicrobot(endwork)" #]
 		terminate 1
	}
}

QActor guiserver context ctxserver{
	[#	var ttState = ws.Transporttrolleystate.IDLE
		var position = ws.Position.HOME
		var plasticCont = 0.0F
		var glassCont = 0.0F
		var ledState = ws.LedState.OFF
		
		val actor = this@Guiserver;
		suspend fun transitNow(stateName : String){
			var res = actor.handleCurrentMessage(NoMsg,actor.getStateByName(stateName));
			if(res) actor.elabMsgInState( );
			else println("ERROR: transition was not possible")
		}
	#]
	
	State wait initial {
		discardMsg Off
		printCurrentMessage
		updateResource [# "gui(wait,${ttState},${position},${ledState},${plasticCont},${glassCont})" #]
		//[# sysUtil.logMsgs=true #]
	}
	Transition t0 whenEvent update_tt_state -> handle_update_tt_state
					whenEvent update_position -> handle_update_position
					whenEvent update_container -> handle_update_container
					whenEvent update_led -> handle_update_led
	
	State handle_update_tt_state {
		printCurrentMessage
		onMsg( update_tt_state:update_tt_state(ARG) ){
			[# ttState = ws.Transporttrolleystate.valueOf(payloadArg(0)) #]
		}
		updateResource [# "gui(handle_update_tt_state,${ttState},${position},${ledState},${plasticCont},${glassCont})" #]
	}
	Goto wait
	
	State handle_update_position {
		printCurrentMessage
		onMsg( update_position:update_position(ARG) ){
			[# position = ws.Position.valueOf(payloadArg(0)) #]
		}
		updateResource [# "gui(handle_update_position,${ttState},${position},${ledState},${plasticCont},${glassCont})" #]
	}
	Goto wait
	
	State handle_update_container {
		printCurrentMessage
		onMsg( update_position:update_position(PLASTIC,GLASS) ){
			[# plasticCont = payloadArg(0).toFloat()
				glassCont = payloadArg(1).toFloat() #]
		}
		updateResource [# "gui(handle_update_container,${ttState},${position},${ledState},${plasticCont},${glassCont})" #]
	}
	Goto wait
	
	State handle_update_led {
		printCurrentMessage
		onMsg( update_position:update_position(ARG) ){
			[# ledState = ws.LedState.valueOf(payloadArg(0)) #]
		}
		updateResource [# "gui(handle_update_led,${ttState},${position},${ledState},${plasticCont},${glassCont})" #]
	}
	Goto wait
}

QActor led context ctxalarm{
	[#	var newState = ws.LedState.OFF
		
		val actor = this@Led;
		suspend fun transitNow(stateName : String){
			var res = actor.handleCurrentMessage(NoMsg,actor.getStateByName(stateName));
			if(res) actor.elabMsgInState( );
			else println("ERROR: transition was not possible")
		}
	#]
	
	State s0 initial {
		discardMsg On
		printCurrentMessage
		updateResource [# "led(initial,${newState})" #]
		//println("${name} STARTS")
		//[# sysUtil.logMsgs=true #]
		println("led off")
	}
	Transition t0 whenEvent update_led -> handle_update
	
	State handle_update {
		printCurrentMessage
		onMsg( update_led:update_led(ARG) ){
			[# newState = ws.LedState.valueOf(payloadArg(0)) #]
			//println("update_led(${newState})")
			[# val stateName = when(newState) {
						ws.LedState.OFF -> "off"
						ws.LedState.ON -> "on"
						ws.LedState.BLINK -> "blink_on"
					}
				transitNow(stateName)
			#]
		}
		updateResource [# "led(handle_update,${newState})" #]
	}
	
	State off {
		printCurrentMessage
		updateResource [# "led(off,${newState})" #]
		println("led off")
	}
	Transition t0 whenEvent update_led -> handle_update
	
	State on {
		printCurrentMessage
		updateResource [# "led(on,${newState})" #]
		println("led on")
	}
	Transition t0 whenEvent update_led -> handle_update
	
	State blink_on {
		printCurrentMessage
		updateResource [# "led(blink_on,${newState})" #]
		println("led on (blinking)")
	}
	Transition t0 whenTime 250 -> blink_off
					whenEvent update_led -> handle_update
					
	State blink_off {
		printCurrentMessage
		updateResource [# "led(blink_off,${newState})" #]
		println("led off (blinking)")
	}
	Transition t0 whenTime 250 -> blink_on
					whenEvent update_led -> handle_update
}



QActor sonar context ctxalarm {	
	State s0 initial {
		printCurrentMessage
		
		//the component emits events
		emit obstacle : obstacle(_)
	}
}


